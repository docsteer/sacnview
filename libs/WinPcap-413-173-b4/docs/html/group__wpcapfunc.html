<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>WinPcap: Exported functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">WinPcap
   &#160;<span id="projectnumber">4.1.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Exported functions<div class="ingroups"><a class="el" href="group__wpcap.html">WinPcap user's manual</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Unix-compatible Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp66235da55168274536ca96ecc6470bf6"></a>These functions are part of the libpcap library, and therefore work both on Windows and on Linux. </p><dl class="section note"><dt>Note</dt><dd>errbuf in <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga6445eeb76f2757b9fa088b276eea2845" title="Create a pcap_t structure without starting a capture. ">pcap_open_dead()</a>, <a class="el" href="group__wpcapfunc.html#ga91078168a13de8848df2b7b83d1f5b69" title="Open a savefile in the tcpdump/libpcap format to read packets. ">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#ga3f212141c80b59aad8ac535bb0178275" title="Switch between blocking and nonblocking mode. ">pcap_setnonblock()</a>, <a class="el" href="group__wpcapfunc.html#gab25dc0bfe06545b86be4103bf010708e" title="Get the &quot;non-blocking&quot; state of an interface. ">pcap_getnonblock()</a>, <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a>, <a class="el" href="group__wpcapfunc.html#gaed295fc9fd86434372e8a8316f1270b1" title="Return the first valid device in the system. ">pcap_lookupdev()</a>, and <a class="el" href="group__wpcapfunc.html#gaa35276d0fa530c51a455f298fa1ec453" title="Return the subnet and netmask of an interface. ">pcap_lookupnet()</a> is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars. </dd></dl>
</td></tr>
<tr class="memitem:gabcba231c099919ecd9300d7160b19878"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gabcba231c099919ecd9300d7160b19878">pcap_handler</a> )(u_char *user, const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pkt_header, const u_char *pkt_data)</td></tr>
<tr class="memdesc:gabcba231c099919ecd9300d7160b19878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of the callback function that receives the packets.  <a href="#gabcba231c099919ecd9300d7160b19878">More...</a><br /></td></tr>
<tr class="separator:gabcba231c099919ecd9300d7160b19878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae6abe06e15c87b803f69773822beca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8">pcap_open_live</a> (const char *device, int snaplen, int promisc, int to_ms, char *ebuf)</td></tr>
<tr class="memdesc:gaae6abe06e15c87b803f69773822beca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a live capture from the network.  <a href="#gaae6abe06e15c87b803f69773822beca8">More...</a><br /></td></tr>
<tr class="separator:gaae6abe06e15c87b803f69773822beca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6445eeb76f2757b9fa088b276eea2845"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga6445eeb76f2757b9fa088b276eea2845">pcap_open_dead</a> (int linktype, int snaplen)</td></tr>
<tr class="memdesc:ga6445eeb76f2757b9fa088b276eea2845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pcap_t structure without starting a capture.  <a href="#ga6445eeb76f2757b9fa088b276eea2845">More...</a><br /></td></tr>
<tr class="separator:ga6445eeb76f2757b9fa088b276eea2845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91078168a13de8848df2b7b83d1f5b69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga91078168a13de8848df2b7b83d1f5b69">pcap_open_offline</a> (const char *fname, char *errbuf)</td></tr>
<tr class="memdesc:ga91078168a13de8848df2b7b83d1f5b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a savefile in the tcpdump/libpcap format to read packets.  <a href="#ga91078168a13de8848df2b7b83d1f5b69">More...</a><br /></td></tr>
<tr class="separator:ga91078168a13de8848df2b7b83d1f5b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9506c33d580fdb5e5c288dba0f8a085c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__wpcap__def.html#gab8c7858aa3a7e3158d9d58cb113a2ae8">pcap_dumper_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga9506c33d580fdb5e5c288dba0f8a085c">pcap_dump_open</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, const char *fname)</td></tr>
<tr class="memdesc:ga9506c33d580fdb5e5c288dba0f8a085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file to write packets.  <a href="#ga9506c33d580fdb5e5c288dba0f8a085c">More...</a><br /></td></tr>
<tr class="separator:ga9506c33d580fdb5e5c288dba0f8a085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f212141c80b59aad8ac535bb0178275"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga3f212141c80b59aad8ac535bb0178275">pcap_setnonblock</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, int nonblock, char *errbuf)</td></tr>
<tr class="memdesc:ga3f212141c80b59aad8ac535bb0178275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch between blocking and nonblocking mode.  <a href="#ga3f212141c80b59aad8ac535bb0178275">More...</a><br /></td></tr>
<tr class="separator:ga3f212141c80b59aad8ac535bb0178275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25dc0bfe06545b86be4103bf010708e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gab25dc0bfe06545b86be4103bf010708e">pcap_getnonblock</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, char *errbuf)</td></tr>
<tr class="memdesc:gab25dc0bfe06545b86be4103bf010708e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "non-blocking" state of an interface.  <a href="#gab25dc0bfe06545b86be4103bf010708e">More...</a><br /></td></tr>
<tr class="separator:gab25dc0bfe06545b86be4103bf010708e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b128eaeef627b408f6a6e2a2f5eb45d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d">pcap_findalldevs</a> (<a class="el" href="group__wpcap__def.html#ga3a6e7cbf8d9752da3add4676c7cd4c58">pcap_if_t</a> **alldevsp, char *errbuf)</td></tr>
<tr class="memdesc:ga7b128eaeef627b408f6a6e2a2f5eb45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a list of network devices that can be opened with <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>.  <a href="#ga7b128eaeef627b408f6a6e2a2f5eb45d">More...</a><br /></td></tr>
<tr class="separator:ga7b128eaeef627b408f6a6e2a2f5eb45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346b4b0b7fd1cda4abb9a39f767dbeb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a> (<a class="el" href="group__wpcap__def.html#ga3a6e7cbf8d9752da3add4676c7cd4c58">pcap_if_t</a> *alldevsp)</td></tr>
<tr class="memdesc:ga346b4b0b7fd1cda4abb9a39f767dbeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an interface list returned by <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a>.  <a href="#ga346b4b0b7fd1cda4abb9a39f767dbeb1">More...</a><br /></td></tr>
<tr class="separator:ga346b4b0b7fd1cda4abb9a39f767dbeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed295fc9fd86434372e8a8316f1270b1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gaed295fc9fd86434372e8a8316f1270b1">pcap_lookupdev</a> (char *errbuf)</td></tr>
<tr class="memdesc:gaed295fc9fd86434372e8a8316f1270b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first valid device in the system.  <a href="#gaed295fc9fd86434372e8a8316f1270b1">More...</a><br /></td></tr>
<tr class="separator:gaed295fc9fd86434372e8a8316f1270b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa35276d0fa530c51a455f298fa1ec453"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gaa35276d0fa530c51a455f298fa1ec453">pcap_lookupnet</a> (const char *device, <a class="el" href="group__wpcap__def.html#ga37fdbc8313e90fb2041203a2e40cd482">bpf_u_int32</a> *netp, <a class="el" href="group__wpcap__def.html#ga37fdbc8313e90fb2041203a2e40cd482">bpf_u_int32</a> *maskp, char *errbuf)</td></tr>
<tr class="memdesc:gaa35276d0fa530c51a455f298fa1ec453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the subnet and netmask of an interface.  <a href="#gaa35276d0fa530c51a455f298fa1ec453">More...</a><br /></td></tr>
<tr class="separator:gaa35276d0fa530c51a455f298fa1ec453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60ce104cdf28420d3361cd36d15be44c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c">pcap_dispatch</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, int cnt, <a class="el" href="group__wpcapfunc.html#gabcba231c099919ecd9300d7160b19878">pcap_handler</a> callback, u_char *user)</td></tr>
<tr class="memdesc:ga60ce104cdf28420d3361cd36d15be44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a group of packets.  <a href="#ga60ce104cdf28420d3361cd36d15be44c">More...</a><br /></td></tr>
<tr class="separator:ga60ce104cdf28420d3361cd36d15be44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bcb7c5c59d76ec16b8a699da136b5de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, int cnt, <a class="el" href="group__wpcapfunc.html#gabcba231c099919ecd9300d7160b19878">pcap_handler</a> callback, u_char *user)</td></tr>
<tr class="memdesc:ga6bcb7c5c59d76ec16b8a699da136b5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a group of packets.  <a href="#ga6bcb7c5c59d76ec16b8a699da136b5de">More...</a><br /></td></tr>
<tr class="separator:ga6bcb7c5c59d76ec16b8a699da136b5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf60257f650aaf869671e0a163611fc3"><td class="memItemLeft" align="right" valign="top">u_char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gadf60257f650aaf869671e0a163611fc3">pcap_next</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *h)</td></tr>
<tr class="memdesc:gadf60257f650aaf869671e0a163611fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next available packet.  <a href="#gadf60257f650aaf869671e0a163611fc3">More...</a><br /></td></tr>
<tr class="separator:gadf60257f650aaf869671e0a163611fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga439439c2eae61161dc1efb1e03a81133"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga439439c2eae61161dc1efb1e03a81133">pcap_next_ex</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> **pkt_header, const u_char **pkt_data)</td></tr>
<tr class="memdesc:ga439439c2eae61161dc1efb1e03a81133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a packet from an interface or from an offline capture.  <a href="#ga439439c2eae61161dc1efb1e03a81133">More...</a><br /></td></tr>
<tr class="separator:ga439439c2eae61161dc1efb1e03a81133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0dc50910fabbd375fab8a1352a6cf33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gae0dc50910fabbd375fab8a1352a6cf33">pcap_breakloop</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *)</td></tr>
<tr class="memdesc:gae0dc50910fabbd375fab8a1352a6cf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a flag that will force <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a> to return rather than looping.  <a href="#gae0dc50910fabbd375fab8a1352a6cf33">More...</a><br /></td></tr>
<tr class="separator:gae0dc50910fabbd375fab8a1352a6cf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51dbda0f1ab9da2cfe49d657486d50b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga51dbda0f1ab9da2cfe49d657486d50b2">pcap_sendpacket</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, u_char *buf, int size)</td></tr>
<tr class="memdesc:ga51dbda0f1ab9da2cfe49d657486d50b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a raw packet.  <a href="#ga51dbda0f1ab9da2cfe49d657486d50b2">More...</a><br /></td></tr>
<tr class="separator:ga51dbda0f1ab9da2cfe49d657486d50b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga659439bf5aa3988b5a92d31990fbf437"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga659439bf5aa3988b5a92d31990fbf437">pcap_dump</a> (u_char *user, const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *h, const u_char *sp)</td></tr>
<tr class="memdesc:ga659439bf5aa3988b5a92d31990fbf437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a packet to disk.  <a href="#ga659439bf5aa3988b5a92d31990fbf437">More...</a><br /></td></tr>
<tr class="separator:ga659439bf5aa3988b5a92d31990fbf437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50de34b8b3298f76c66c82b7ca3f84de"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga50de34b8b3298f76c66c82b7ca3f84de">pcap_dump_ftell</a> (<a class="el" href="group__wpcap__def.html#gab8c7858aa3a7e3158d9d58cb113a2ae8">pcap_dumper_t</a> *)</td></tr>
<tr class="memdesc:ga50de34b8b3298f76c66c82b7ca3f84de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the file position for a "savefile".  <a href="#ga50de34b8b3298f76c66c82b7ca3f84de">More...</a><br /></td></tr>
<tr class="separator:ga50de34b8b3298f76c66c82b7ca3f84de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363bdc6f6b39b4979ddcf15ecb830c5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga363bdc6f6b39b4979ddcf15ecb830c5c">pcap_compile</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, struct bpf_program *fp, char *str, int optimize, <a class="el" href="group__wpcap__def.html#ga37fdbc8313e90fb2041203a2e40cd482">bpf_u_int32</a> netmask)</td></tr>
<tr class="memdesc:ga363bdc6f6b39b4979ddcf15ecb830c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a packet filter, converting an high level filtering expression (see <a class="el" href="group__language.html">Filtering expression syntax</a>) in a program that can be interpreted by the kernel-level filtering engine.  <a href="#ga363bdc6f6b39b4979ddcf15ecb830c5c">More...</a><br /></td></tr>
<tr class="separator:ga363bdc6f6b39b4979ddcf15ecb830c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8325b202dad14a00609db8372722ae4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga8325b202dad14a00609db8372722ae4e">pcap_compile_nopcap</a> (int snaplen_arg, int linktype_arg, struct bpf_program *program, char *buf, int optimize, <a class="el" href="group__wpcap__def.html#ga37fdbc8313e90fb2041203a2e40cd482">bpf_u_int32</a> mask)</td></tr>
<tr class="memdesc:ga8325b202dad14a00609db8372722ae4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a packet filter without the need of opening an adapter. This function converts an high level filtering expression (see <a class="el" href="group__language.html">Filtering expression syntax</a>) in a program that can be interpreted by the kernel-level filtering engine.  <a href="#ga8325b202dad14a00609db8372722ae4e">More...</a><br /></td></tr>
<tr class="separator:ga8325b202dad14a00609db8372722ae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f9cfe85dad0967ff607e5159b1ba61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gaf5f9cfe85dad0967ff607e5159b1ba61">pcap_setfilter</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, struct bpf_program *fp)</td></tr>
<tr class="memdesc:gaf5f9cfe85dad0967ff607e5159b1ba61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a filter to a capture.  <a href="#gaf5f9cfe85dad0967ff607e5159b1ba61">More...</a><br /></td></tr>
<tr class="separator:gaf5f9cfe85dad0967ff607e5159b1ba61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e0a5aad1a5dc79d85f1edfcebe0ac13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga9e0a5aad1a5dc79d85f1edfcebe0ac13">pcap_freecode</a> (struct bpf_program *fp)</td></tr>
<tr class="memdesc:ga9e0a5aad1a5dc79d85f1edfcebe0ac13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a filter.  <a href="#ga9e0a5aad1a5dc79d85f1edfcebe0ac13">More...</a><br /></td></tr>
<tr class="separator:ga9e0a5aad1a5dc79d85f1edfcebe0ac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c019f851f7da6892d51cca15f12ace"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga64c019f851f7da6892d51cca15f12ace">pcap_datalink</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p)</td></tr>
<tr class="memdesc:ga64c019f851f7da6892d51cca15f12ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the link layer of an adapter.  <a href="#ga64c019f851f7da6892d51cca15f12ace">More...</a><br /></td></tr>
<tr class="separator:ga64c019f851f7da6892d51cca15f12ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64e482360b0ed7d65fce1db23d56b921"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga64e482360b0ed7d65fce1db23d56b921">pcap_list_datalinks</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, int **dlt_buf)</td></tr>
<tr class="memdesc:ga64e482360b0ed7d65fce1db23d56b921"><td class="mdescLeft">&#160;</td><td class="mdescRight">list datalinks  <a href="#ga64e482360b0ed7d65fce1db23d56b921">More...</a><br /></td></tr>
<tr class="separator:ga64e482360b0ed7d65fce1db23d56b921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9588b99ac118cf827873d9e941eb6c77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga9588b99ac118cf827873d9e941eb6c77">pcap_set_datalink</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, int dlt)</td></tr>
<tr class="memdesc:ga9588b99ac118cf827873d9e941eb6c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current data link type of the pcap descriptor to the type specified by dlt. -1 is returned on failure.  <a href="#ga9588b99ac118cf827873d9e941eb6c77">More...</a><br /></td></tr>
<tr class="separator:ga9588b99ac118cf827873d9e941eb6c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga440b2f0757acd4804588933324909207"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga440b2f0757acd4804588933324909207">pcap_datalink_name_to_val</a> (const char *name)</td></tr>
<tr class="memdesc:ga440b2f0757acd4804588933324909207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a data link type name, which is a DLT_ name with the DLT_ removed, to the corresponding data link type value. The translation is case-insensitive. -1 is returned on failure.  <a href="#ga440b2f0757acd4804588933324909207">More...</a><br /></td></tr>
<tr class="separator:ga440b2f0757acd4804588933324909207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad45c16d494577f1886704af8f31ed442"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gad45c16d494577f1886704af8f31ed442">pcap_datalink_val_to_name</a> (int dlt)</td></tr>
<tr class="memdesc:gad45c16d494577f1886704af8f31ed442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a data link type value to the corresponding data link type name. NULL is returned on failure.  <a href="#gad45c16d494577f1886704af8f31ed442">More...</a><br /></td></tr>
<tr class="separator:gad45c16d494577f1886704af8f31ed442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f142cd0694b49357e4a73371db71411"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga3f142cd0694b49357e4a73371db71411">pcap_datalink_val_to_description</a> (int dlt)</td></tr>
<tr class="memdesc:ga3f142cd0694b49357e4a73371db71411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a data link type value to a short description of that data link type. NULL is returned on failure.  <a href="#ga3f142cd0694b49357e4a73371db71411">More...</a><br /></td></tr>
<tr class="separator:ga3f142cd0694b49357e4a73371db71411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c6e9768e89a6b82f9d720f37e6ab97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gae5c6e9768e89a6b82f9d720f37e6ab97">pcap_snapshot</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p)</td></tr>
<tr class="memdesc:gae5c6e9768e89a6b82f9d720f37e6ab97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the packet portion (in bytes) that is delivered to the application.  <a href="#gae5c6e9768e89a6b82f9d720f37e6ab97">More...</a><br /></td></tr>
<tr class="separator:gae5c6e9768e89a6b82f9d720f37e6ab97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba4941e09e5e03ba39841de4b1d5d6a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gaba4941e09e5e03ba39841de4b1d5d6a4">pcap_is_swapped</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p)</td></tr>
<tr class="memdesc:gaba4941e09e5e03ba39841de4b1d5d6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the current savefile uses a different byte order than the current system.  <a href="#gaba4941e09e5e03ba39841de4b1d5d6a4">More...</a><br /></td></tr>
<tr class="separator:gaba4941e09e5e03ba39841de4b1d5d6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39dfb05149b443cc25b8febc455ca753"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga39dfb05149b443cc25b8febc455ca753">pcap_major_version</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p)</td></tr>
<tr class="memdesc:ga39dfb05149b443cc25b8febc455ca753"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the major version number of the pcap library used to write the savefile.  <a href="#ga39dfb05149b443cc25b8febc455ca753">More...</a><br /></td></tr>
<tr class="separator:ga39dfb05149b443cc25b8febc455ca753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7a9dd9cd040ee500221cf35dfb49248"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gac7a9dd9cd040ee500221cf35dfb49248">pcap_minor_version</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p)</td></tr>
<tr class="memdesc:gac7a9dd9cd040ee500221cf35dfb49248"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the minor version number of the pcap library used to write the savefile.  <a href="#gac7a9dd9cd040ee500221cf35dfb49248">More...</a><br /></td></tr>
<tr class="separator:gac7a9dd9cd040ee500221cf35dfb49248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c9f5690b99fb2af1f8904403f7da06b"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga4c9f5690b99fb2af1f8904403f7da06b">pcap_file</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p)</td></tr>
<tr class="memdesc:ga4c9f5690b99fb2af1f8904403f7da06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the standard stream of an offline capture.  <a href="#ga4c9f5690b99fb2af1f8904403f7da06b">More...</a><br /></td></tr>
<tr class="separator:ga4c9f5690b99fb2af1f8904403f7da06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd74d8c3ce1bcbccc76129ac38f4549"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gabbd74d8c3ce1bcbccc76129ac38f4549">pcap_stats</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, struct <a class="el" href="structpcap__stat.html">pcap_stat</a> *ps)</td></tr>
<tr class="memdesc:gabbd74d8c3ce1bcbccc76129ac38f4549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return statistics on current capture.  <a href="#gabbd74d8c3ce1bcbccc76129ac38f4549">More...</a><br /></td></tr>
<tr class="separator:gabbd74d8c3ce1bcbccc76129ac38f4549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3b6784c6c2623b93b22f6f219bd470e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gac3b6784c6c2623b93b22f6f219bd470e">pcap_perror</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, char *prefix)</td></tr>
<tr class="memdesc:gac3b6784c6c2623b93b22f6f219bd470e"><td class="mdescLeft">&#160;</td><td class="mdescRight">print the text of the last pcap library error on stderr, prefixed by prefix.  <a href="#gac3b6784c6c2623b93b22f6f219bd470e">More...</a><br /></td></tr>
<tr class="separator:gac3b6784c6c2623b93b22f6f219bd470e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81305cb154e4497e95bbb9b708631a3a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga81305cb154e4497e95bbb9b708631a3a">pcap_geterr</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p)</td></tr>
<tr class="memdesc:ga81305cb154e4497e95bbb9b708631a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the error text pertaining to the last pcap library error.  <a href="#ga81305cb154e4497e95bbb9b708631a3a">More...</a><br /></td></tr>
<tr class="separator:ga81305cb154e4497e95bbb9b708631a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac2067e8f66f5a5a87f19f5e2b5ad4f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gafac2067e8f66f5a5a87f19f5e2b5ad4f">pcap_strerror</a> (int error)</td></tr>
<tr class="memdesc:gafac2067e8f66f5a5a87f19f5e2b5ad4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provided in case strerror() isn't available.  <a href="#gafac2067e8f66f5a5a87f19f5e2b5ad4f">More...</a><br /></td></tr>
<tr class="separator:gafac2067e8f66f5a5a87f19f5e2b5ad4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d92cec9ff55906b5b6fb883e4bd72f4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga2d92cec9ff55906b5b6fb883e4bd72f4">pcap_lib_version</a> (void)</td></tr>
<tr class="memdesc:ga2d92cec9ff55906b5b6fb883e4bd72f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a string giving information about the version of the libpcap library being used; note that it contains more information than just a version number.  <a href="#ga2d92cec9ff55906b5b6fb883e4bd72f4">More...</a><br /></td></tr>
<tr class="separator:ga2d92cec9ff55906b5b6fb883e4bd72f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45a5e1a4ba9925bb3586dcbeec78560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gaa45a5e1a4ba9925bb3586dcbeec78560">pcap_close</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p)</td></tr>
<tr class="memdesc:gaa45a5e1a4ba9925bb3586dcbeec78560"><td class="mdescLeft">&#160;</td><td class="mdescRight">close the files associated with p and deallocates resources.  <a href="#gaa45a5e1a4ba9925bb3586dcbeec78560">More...</a><br /></td></tr>
<tr class="separator:gaa45a5e1a4ba9925bb3586dcbeec78560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dac02f297422ff2ab5983d1e30c58b6"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga8dac02f297422ff2ab5983d1e30c58b6">pcap_dump_file</a> (<a class="el" href="group__wpcap__def.html#gab8c7858aa3a7e3158d9d58cb113a2ae8">pcap_dumper_t</a> *p)</td></tr>
<tr class="memdesc:ga8dac02f297422ff2ab5983d1e30c58b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the standard I/O stream of the 'savefile' opened by <a class="el" href="group__wpcapfunc.html#ga9506c33d580fdb5e5c288dba0f8a085c" title="Open a file to write packets. ">pcap_dump_open()</a>.  <a href="#ga8dac02f297422ff2ab5983d1e30c58b6">More...</a><br /></td></tr>
<tr class="separator:ga8dac02f297422ff2ab5983d1e30c58b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90404ae3dcffcd3bbe78f8b187a88984"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga90404ae3dcffcd3bbe78f8b187a88984">pcap_dump_flush</a> (<a class="el" href="group__wpcap__def.html#gab8c7858aa3a7e3158d9d58cb113a2ae8">pcap_dumper_t</a> *p)</td></tr>
<tr class="memdesc:ga90404ae3dcffcd3bbe78f8b187a88984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the output buffer to the <code>savefile,'' so that any packets written with <a class="el" href="group__wpcapfunc.html#ga659439bf5aa3988b5a92d31990fbf437" title="Save a packet to disk. ">pcap_dump()</a> but not yet written to the</code>savefile'' will be written. -1 is returned on error, 0 on success.  <a href="#ga90404ae3dcffcd3bbe78f8b187a88984">More...</a><br /></td></tr>
<tr class="separator:ga90404ae3dcffcd3bbe78f8b187a88984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3897795c1e9fb10571092febae964ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga3897795c1e9fb10571092febae964ef0">pcap_dump_close</a> (<a class="el" href="group__wpcap__def.html#gab8c7858aa3a7e3158d9d58cb113a2ae8">pcap_dumper_t</a> *p)</td></tr>
<tr class="memdesc:ga3897795c1e9fb10571092febae964ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a savefile.  <a href="#ga3897795c1e9fb10571092febae964ef0">More...</a><br /></td></tr>
<tr class="separator:ga3897795c1e9fb10571092febae964ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Windows-specific Extensions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp06003dbc75790df77036476ed55327c8"></a>The functions in this section extend libpcap to offer advanced functionalities (like remote packet capture, packet buffer size variation or high-precision packet injection). Howerver, at the moment they can be used only in Windows. </p>
</td></tr>
<tr class="memitem:ga4c8f8d1b9238c74faa156494a6b98670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Win32-Extensions_8h.html#aadfdcc0e37082d8f6b28a43ec9a0bccf">PAirpcapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga4c8f8d1b9238c74faa156494a6b98670">pcap_get_airpcap_handle</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p)</td></tr>
<tr class="memdesc:ga4c8f8d1b9238c74faa156494a6b98670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AirPcap handler associated with an adapter. This handler can be used to change the wireless-related settings of the CACE Technologies AirPcap wireless capture adapters.  <a href="#ga4c8f8d1b9238c74faa156494a6b98670">More...</a><br /></td></tr>
<tr class="separator:ga4c8f8d1b9238c74faa156494a6b98670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae92f11bfb001c19b2d0fbcd6821d222a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gae92f11bfb001c19b2d0fbcd6821d222a">pcap_offline_filter</a> (struct bpf_program *prog, const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, const u_char *pkt_data)</td></tr>
<tr class="memdesc:gae92f11bfb001c19b2d0fbcd6821d222a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if a given filter applies to an offline packet.  <a href="#gae92f11bfb001c19b2d0fbcd6821d222a">More...</a><br /></td></tr>
<tr class="separator:gae92f11bfb001c19b2d0fbcd6821d222a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedef54159d918b22a7de8e75b8a3ef4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gaedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, char *filename, int maxsize, int maxpacks)</td></tr>
<tr class="memdesc:gaedef54159d918b22a7de8e75b8a3ef4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a capture to file.  <a href="#gaedef54159d918b22a7de8e75b8a3ef4d">More...</a><br /></td></tr>
<tr class="separator:gaedef54159d918b22a7de8e75b8a3ef4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe8a334f3a7ae2dc7f52e96523da39be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gafe8a334f3a7ae2dc7f52e96523da39be">pcap_live_dump_ended</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, int sync)</td></tr>
<tr class="memdesc:gafe8a334f3a7ae2dc7f52e96523da39be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the kernel dump process, i.e. tells if one of the limits defined with <a class="el" href="group__wpcapfunc.html#gaedef54159d918b22a7de8e75b8a3ef4d" title="Save a capture to file. ">pcap_live_dump()</a> has been reached.  <a href="#gafe8a334f3a7ae2dc7f52e96523da39be">More...</a><br /></td></tr>
<tr class="separator:gafe8a334f3a7ae2dc7f52e96523da39be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8050f7829956aabd243cc32b3cfabbd6"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpcap__stat.html">pcap_stat</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga8050f7829956aabd243cc32b3cfabbd6">pcap_stats_ex</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, int *pcap_stat_size)</td></tr>
<tr class="memdesc:ga8050f7829956aabd243cc32b3cfabbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return statistics on current capture.  <a href="#ga8050f7829956aabd243cc32b3cfabbd6">More...</a><br /></td></tr>
<tr class="separator:ga8050f7829956aabd243cc32b3cfabbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga124bde25ccd9e39017ff2abec2dda623"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga124bde25ccd9e39017ff2abec2dda623">pcap_setbuff</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, int dim)</td></tr>
<tr class="memdesc:ga124bde25ccd9e39017ff2abec2dda623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the kernel buffer associated with an adapter.  <a href="#ga124bde25ccd9e39017ff2abec2dda623">More...</a><br /></td></tr>
<tr class="separator:ga124bde25ccd9e39017ff2abec2dda623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef07ef49d3c75644f3fd34518e2fe720"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gaef07ef49d3c75644f3fd34518e2fe720">pcap_setmode</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, int mode)</td></tr>
<tr class="memdesc:gaef07ef49d3c75644f3fd34518e2fe720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the working mode of the interface p to mode.  <a href="#gaef07ef49d3c75644f3fd34518e2fe720">More...</a><br /></td></tr>
<tr class="separator:gaef07ef49d3c75644f3fd34518e2fe720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab14ceacbf1c2f63026416dd73f80dc0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gab14ceacbf1c2f63026416dd73f80dc0d">pcap_setmintocopy</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, int size)</td></tr>
<tr class="memdesc:gab14ceacbf1c2f63026416dd73f80dc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minumum amount of data received by the kernel in a single call.  <a href="#gab14ceacbf1c2f63026416dd73f80dc0d">More...</a><br /></td></tr>
<tr class="separator:gab14ceacbf1c2f63026416dd73f80dc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c415e9192c7b18a81a02300ae6f2c02"><td class="memItemLeft" align="right" valign="top">HANDLE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga2c415e9192c7b18a81a02300ae6f2c02">pcap_getevent</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p)</td></tr>
<tr class="memdesc:ga2c415e9192c7b18a81a02300ae6f2c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the handle of the event associated with the interface p.  <a href="#ga2c415e9192c7b18a81a02300ae6f2c02">More...</a><br /></td></tr>
<tr class="separator:ga2c415e9192c7b18a81a02300ae6f2c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab940e69631b7cc7f2232a69ea02b86d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gab940e69631b7cc7f2232a69ea02b86d9">pcap_sendqueue_alloc</a> (u_int memsize)</td></tr>
<tr class="memdesc:gab940e69631b7cc7f2232a69ea02b86d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a send queue.  <a href="#gab940e69631b7cc7f2232a69ea02b86d9">More...</a><br /></td></tr>
<tr class="separator:gab940e69631b7cc7f2232a69ea02b86d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72624f7a9932cc2124abf661001e0aa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga72624f7a9932cc2124abf661001e0aa4">pcap_sendqueue_destroy</a> (<a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *queue)</td></tr>
<tr class="memdesc:ga72624f7a9932cc2124abf661001e0aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a send queue.  <a href="#ga72624f7a9932cc2124abf661001e0aa4">More...</a><br /></td></tr>
<tr class="separator:ga72624f7a9932cc2124abf661001e0aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c57ea320d71dbfe55c5665af9db1297"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga4c57ea320d71dbfe55c5665af9db1297">pcap_sendqueue_queue</a> (<a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *queue, const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pkt_header, const u_char *pkt_data)</td></tr>
<tr class="memdesc:ga4c57ea320d71dbfe55c5665af9db1297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a packet to a send queue.  <a href="#ga4c57ea320d71dbfe55c5665af9db1297">More...</a><br /></td></tr>
<tr class="separator:ga4c57ea320d71dbfe55c5665af9db1297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4d55eb047a1cccc0e28397ce04ee097"><td class="memItemLeft" align="right" valign="top">u_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gaa4d55eb047a1cccc0e28397ce04ee097">pcap_sendqueue_transmit</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p, <a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *queue, int sync)</td></tr>
<tr class="memdesc:gaa4d55eb047a1cccc0e28397ce04ee097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a queue of raw packets to the network.  <a href="#gaa4d55eb047a1cccc0e28397ce04ee097">More...</a><br /></td></tr>
<tr class="separator:gaa4d55eb047a1cccc0e28397ce04ee097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f36e62c95c6ad81eaa8b2bbeb8f16e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga98f36e62c95c6ad81eaa8b2bbeb8f16e">pcap_findalldevs_ex</a> (char *source, struct pcap_rmtauth *auth, <a class="el" href="group__wpcap__def.html#ga3a6e7cbf8d9752da3add4676c7cd4c58">pcap_if_t</a> **alldevs, char *errbuf)</td></tr>
<tr class="memdesc:ga98f36e62c95c6ad81eaa8b2bbeb8f16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list of network devices that can be opened with <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a>.  <a href="#ga98f36e62c95c6ad81eaa8b2bbeb8f16e">More...</a><br /></td></tr>
<tr class="separator:ga98f36e62c95c6ad81eaa8b2bbeb8f16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3111e10f930a9772a32a922b26948b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#gaa3111e10f930a9772a32a922b26948b0">pcap_createsrcstr</a> (char *source, int type, const char *host, const char *port, const char *name, char *errbuf)</td></tr>
<tr class="memdesc:gaa3111e10f930a9772a32a922b26948b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a set of strings (host name, port, ...), and it returns the complete source string according to the new format (e.g. 'rpcap://1.2.3.4/eth0').  <a href="#gaa3111e10f930a9772a32a922b26948b0">More...</a><br /></td></tr>
<tr class="separator:gaa3111e10f930a9772a32a922b26948b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga090e0afd3f463b4b60a64c47eddc1ba2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga090e0afd3f463b4b60a64c47eddc1ba2">pcap_parsesrcstr</a> (const char *source, int *type, char *host, char *port, char *name, char *errbuf)</td></tr>
<tr class="memdesc:ga090e0afd3f463b4b60a64c47eddc1ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the source string and returns the pieces in which the source can be split.  <a href="#ga090e0afd3f463b4b60a64c47eddc1ba2">More...</a><br /></td></tr>
<tr class="separator:ga090e0afd3f463b4b60a64c47eddc1ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b64c7b6490090d1d37088794f1f1791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791">pcap_open</a> (const char *source, int snaplen, int flags, int read_timeout, struct pcap_rmtauth *auth, char *errbuf)</td></tr>
<tr class="memdesc:ga2b64c7b6490090d1d37088794f1f1791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a generic source in order to capture / send (WinPcap only) traffic.  <a href="#ga2b64c7b6490090d1d37088794f1f1791">More...</a><br /></td></tr>
<tr class="separator:ga2b64c7b6490090d1d37088794f1f1791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84c7d55f5b0e7d545b38d6b8e7bde005"><td class="memItemLeft" align="right" valign="top">struct pcap_samp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga84c7d55f5b0e7d545b38d6b8e7bde005">pcap_setsampling</a> (<a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *p)</td></tr>
<tr class="memdesc:ga84c7d55f5b0e7d545b38d6b8e7bde005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a sampling method for packet capture.  <a href="#ga84c7d55f5b0e7d545b38d6b8e7bde005">More...</a><br /></td></tr>
<tr class="separator:ga84c7d55f5b0e7d545b38d6b8e7bde005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5495943cc8262db57f726e2a23f837dd"><td class="memItemLeft" align="right" valign="top">SOCKET&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga5495943cc8262db57f726e2a23f837dd">pcap_remoteact_accept</a> (const char *address, const char *port, const char *hostlist, char *connectinghost, struct pcap_rmtauth *auth, char *errbuf)</td></tr>
<tr class="memdesc:ga5495943cc8262db57f726e2a23f837dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until a network connection is accepted (active mode only).  <a href="#ga5495943cc8262db57f726e2a23f837dd">More...</a><br /></td></tr>
<tr class="separator:ga5495943cc8262db57f726e2a23f837dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a84e03497f946d61c440696e57e2c95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga6a84e03497f946d61c440696e57e2c95">pcap_remoteact_close</a> (const char *host, char *errbuf)</td></tr>
<tr class="memdesc:ga6a84e03497f946d61c440696e57e2c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop an active connection (active mode only).  <a href="#ga6a84e03497f946d61c440696e57e2c95">More...</a><br /></td></tr>
<tr class="separator:ga6a84e03497f946d61c440696e57e2c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b022e0a67f5ff62fd13df5c688d6d82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga7b022e0a67f5ff62fd13df5c688d6d82">pcap_remoteact_cleanup</a> ()</td></tr>
<tr class="memdesc:ga7b022e0a67f5ff62fd13df5c688d6d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean the socket that is currently used in waiting active connections.  <a href="#ga7b022e0a67f5ff62fd13df5c688d6d82">More...</a><br /></td></tr>
<tr class="separator:ga7b022e0a67f5ff62fd13df5c688d6d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ee8f666bff537aa457b7c05651cf815"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wpcapfunc.html#ga7ee8f666bff537aa457b7c05651cf815">pcap_remoteact_list</a> (char *hostlist, char sep, int size, char *errbuf)</td></tr>
<tr class="memdesc:ga7ee8f666bff537aa457b7c05651cf815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hostname of the host that have an active connection with us (active mode only).  <a href="#ga7ee8f666bff537aa457b7c05651cf815">More...</a><br /></td></tr>
<tr class="separator:ga7ee8f666bff537aa457b7c05651cf815"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions exported by wpcap.dll </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gabcba231c099919ecd9300d7160b19878"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pcap_handler)(u_char *user, const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pkt_header, const u_char *pkt_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype of the callback function that receives the packets. </p>
<p>When <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a> are called by the user, the packets are passed to the application by means of this callback. user is a user-defined parameter that contains the state of the capture session, it corresponds to the <em>user</em> parameter of <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> and <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a>. pkt_header is the header associated by the capture driver to the packet. It is NOT a protocol header. pkt_data points to the data of the packet, including the protocol headers. </p>

<p>Definition at line <a class="el" href="funcs_2pcap_8h_source.html#l00027">27</a> of file <a class="el" href="funcs_2pcap_8h_source.html">funcs/pcap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae0dc50910fabbd375fab8a1352a6cf33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcap_breakloop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a flag that will force <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a> to return rather than looping. </p>
<p>They will return the number of packets that have been processed so far, or -2 if no packets have been processed so far. This routine is safe to use inside a signal handler on UNIX or a console control handler on Windows, as it merely sets a flag that is checked within the loop. The flag is checked in loops reading packets from the OS - a signal by itself will not necessarily terminate those loops - as well as in loops processing a set of packets returned by the OS. Note that if you are catching signals on UNIX systems that support restarting system calls after a signal, and calling <a class="el" href="group__wpcapfunc.html#gae0dc50910fabbd375fab8a1352a6cf33" title="set a flag that will force pcap_dispatch() or pcap_loop() to return rather than looping. ">pcap_breakloop()</a> in the signal handler, you must specify, when catching those signals, that system calls should NOT be restarted by that signal. Otherwise, if the signal interrupted a call reading packets in a live capture, when your signal handler returns after calling <a class="el" href="group__wpcapfunc.html#gae0dc50910fabbd375fab8a1352a6cf33" title="set a flag that will force pcap_dispatch() or pcap_loop() to return rather than looping. ">pcap_breakloop()</a>, the call will be restarted, and the loop will not terminate until more packets arrive and the call completes. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="group__wpcapfunc.html#gadf60257f650aaf869671e0a163611fc3" title="Return the next available packet. ">pcap_next()</a> will, on some platforms, loop reading packets from the OS; that loop will not necessarily be terminated by a signal, so <a class="el" href="group__wpcapfunc.html#gae0dc50910fabbd375fab8a1352a6cf33" title="set a flag that will force pcap_dispatch() or pcap_loop() to return rather than looping. ">pcap_breakloop()</a> should be used to terminate packet processing even if <a class="el" href="group__wpcapfunc.html#gadf60257f650aaf869671e0a163611fc3" title="Return the next available packet. ">pcap_next()</a> is being used. <a class="el" href="group__wpcapfunc.html#gae0dc50910fabbd375fab8a1352a6cf33" title="set a flag that will force pcap_dispatch() or pcap_loop() to return rather than looping. ">pcap_breakloop()</a> does not guarantee that no further packets will be processed by <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a> after it is called; at most one more packet might be processed. If -2 is returned from <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a>, the flag is cleared, so a subsequent call will resume reading packets. If a positive number is returned, the flag is not cleared, so a subsequent call will return -2 and clear the flag. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa45a5e1a4ba9925bb3586dcbeec78560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcap_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>close the files associated with p and deallocates resources. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga91078168a13de8848df2b7b83d1f5b69" title="Open a savefile in the tcpdump/libpcap format to read packets. ">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#ga6445eeb76f2757b9fa088b276eea2845" title="Create a pcap_t structure without starting a capture. ">pcap_open_dead()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga363bdc6f6b39b4979ddcf15ecb830c5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_compile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bpf_program *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optimize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga37fdbc8313e90fb2041203a2e40cd482">bpf_u_int32</a>&#160;</td>
          <td class="paramname"><em>netmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a packet filter, converting an high level filtering expression (see <a class="el" href="group__language.html">Filtering expression syntax</a>) in a program that can be interpreted by the kernel-level filtering engine. </p>
<p><a class="el" href="group__wpcapfunc.html#ga363bdc6f6b39b4979ddcf15ecb830c5c" title="Compile a packet filter, converting an high level filtering expression (see Filtering expression synt...">pcap_compile()</a> is used to compile the string str into a filter program. program is a pointer to a bpf_program struct and is filled in by <a class="el" href="group__wpcapfunc.html#ga363bdc6f6b39b4979ddcf15ecb830c5c" title="Compile a packet filter, converting an high level filtering expression (see Filtering expression synt...">pcap_compile()</a>. optimize controls whether optimization on the resulting code is performed. netmask specifies the IPv4 netmask of the network on which packets are being captured; it is used only when checking for IPv4 broadcast addresses in the filter program. If the netmask of the network on which packets are being captured isn't known to the program, or if packets are being captured on the Linux "any" pseudo-interface that can capture on more than one network, a value of 0 can be supplied; tests for IPv4 broadcast addreses won't be done correctly, but all other tests in the filter program will be OK. A return of -1 indicates an error in which case <a class="el" href="group__wpcapfunc.html#ga81305cb154e4497e95bbb9b708631a3a" title="return the error text pertaining to the last pcap library error. ">pcap_geterr()</a> may be used to display the error text.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#gaf5f9cfe85dad0967ff607e5159b1ba61" title="Associate a filter to a capture. ">pcap_setfilter()</a>, <a class="el" href="group__wpcapfunc.html#ga9e0a5aad1a5dc79d85f1edfcebe0ac13" title="Free a filter. ">pcap_freecode()</a>, <a class="el" href="group__wpcapfunc.html#gae5c6e9768e89a6b82f9d720f37e6ab97" title="Return the dimension of the packet portion (in bytes) that is delivered to the application. ">pcap_snapshot()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8325b202dad14a00609db8372722ae4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_compile_nopcap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>snaplen_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linktype_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bpf_program *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optimize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga37fdbc8313e90fb2041203a2e40cd482">bpf_u_int32</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a packet filter without the need of opening an adapter. This function converts an high level filtering expression (see <a class="el" href="group__language.html">Filtering expression syntax</a>) in a program that can be interpreted by the kernel-level filtering engine. </p>
<p><a class="el" href="group__wpcapfunc.html#ga8325b202dad14a00609db8372722ae4e" title="Compile a packet filter without the need of opening an adapter. This function converts an high level ...">pcap_compile_nopcap()</a> is similar to <a class="el" href="group__wpcapfunc.html#ga363bdc6f6b39b4979ddcf15ecb830c5c" title="Compile a packet filter, converting an high level filtering expression (see Filtering expression synt...">pcap_compile()</a> except that instead of passing a pcap structure, one passes the snaplen and linktype explicitly. It is intended to be used for compiling filters for direct BPF usage, without necessarily having called <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a>. A return of -1 indicates an error; the error text is unavailable. (<a class="el" href="group__wpcapfunc.html#ga8325b202dad14a00609db8372722ae4e" title="Compile a packet filter without the need of opening an adapter. This function converts an high level ...">pcap_compile_nopcap()</a> is a wrapper around <a class="el" href="group__wpcapfunc.html#ga6445eeb76f2757b9fa088b276eea2845" title="Create a pcap_t structure without starting a capture. ">pcap_open_dead()</a>, <a class="el" href="group__wpcapfunc.html#ga363bdc6f6b39b4979ddcf15ecb830c5c" title="Compile a packet filter, converting an high level filtering expression (see Filtering expression synt...">pcap_compile()</a>, and <a class="el" href="group__wpcapfunc.html#gaa45a5e1a4ba9925bb3586dcbeec78560" title="close the files associated with p and deallocates resources. ">pcap_close()</a>; the latter three routines can be used directly in order to get the error text for a compilation error.)</p>
<p>Look at the <a class="el" href="group__language.html">Filtering expression syntax</a> section for details on the str parameter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#gaf5f9cfe85dad0967ff607e5159b1ba61" title="Associate a filter to a capture. ">pcap_setfilter()</a>, <a class="el" href="group__wpcapfunc.html#ga9e0a5aad1a5dc79d85f1edfcebe0ac13" title="Free a filter. ">pcap_freecode()</a>, <a class="el" href="group__wpcapfunc.html#gae5c6e9768e89a6b82f9d720f37e6ab97" title="Return the dimension of the packet portion (in bytes) that is delivered to the application. ">pcap_snapshot()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa3111e10f930a9772a32a922b26948b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_createsrcstr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a set of strings (host name, port, ...), and it returns the complete source string according to the new format (e.g. 'rpcap://1.2.3.4/eth0'). </p>
<p>This function is provided in order to help the user creating the source string according to the new format. An unique source string is used in order to make easy for old applications to use the remote facilities. Think about tcpdump, for example, which has only one way to specify the interface on which the capture has to be started. However, GUI-based programs can find more useful to specify hostname, port and interface name separately. In that case, they can use this function to create the source string before passing it to the <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>a user-allocated buffer that will contain the complete source string wen the function returns.<br />
 The source will start with an identifier according to the new <a class="el" href="group__remote__source__string.html">Source Specification Syntax </a>.<br />
 This function assumes that the allocated buffer is at least PCAP_BUF_SIZE bytes.</td></tr>
    <tr><td class="paramname">type</td><td>its value tells the type of the source we want to create. It can assume the values defined in the <a class="el" href="group__remote__source__ID.html">Source identification Codes </a>.<br />
</td></tr>
    <tr><td class="paramname">host</td><td>an user-allocated buffer that keeps the host (e.g. "foo.bar.com") we want to connect to. It can be NULL in case we want to open an interface on a local host.</td></tr>
    <tr><td class="paramname">port</td><td>an user-allocated buffer that keeps the network port (e.g. "2002") we want to use for the RPCAP protocol. It can be NULL in case we want to open an interface on a local host.</td></tr>
    <tr><td class="paramname">name</td><td>an user-allocated buffer that keeps the interface name we want to use (e.g. "eth0"). It can be NULL in case the return string (i.e. 'source') has to be used with the <a class="el" href="group__wpcapfunc.html#ga98f36e62c95c6ad81eaa8b2bbeb8f16e" title="Create a list of network devices that can be opened with pcap_open(). ">pcap_findalldevs_ex()</a>, which does not require the interface name.</td></tr>
    <tr><td class="paramname">errbuf</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'0' if everything is fine, '-1' if some errors occurred. The string containing the complete source is returned in the 'source' variable.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the source is longer than PCAP_BUF_SIZE, the excess characters are truncated. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64c019f851f7da6892d51cca15f12ace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_datalink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the link layer of an adapter. </p>
<p>returns the link layer type; link layer types it can return include: </p><pre class="fragment">- DLT_NULL BSD loopback encapsulation; the link layer header is a 4-byte field, in host byte order, containing a PF_ value from socket.h for the network-layer protocol of the packet. 
    Note that ``host byte order'' is the byte order of the machine on which the packets are captured, and the PF_ values are for the OS of the machine on which the packets are captured; if a live capture is being done, ``host byte order'' is the byte order of the machine capturing the packets, and the PF_ values are those of the OS of the machine capturing the packets, but if a ``savefile'' is being read, the byte order and PF_ values are not necessarily those of the machine reading the capture file. 
- DLT_EN10MB Ethernet (10Mb, 100Mb, 1000Mb, and up) 
- DLT_IEEE802: IEEE 802.5 Token Ring 
- DLT_ARCNET: ARCNET 
- DLT_SLIP: SLIP; the link layer header contains, in order:
        -# a 1-byte flag, which is 0 for packets received by the machine and 1 for packets sent by the machine;
        -# a 1-byte field, the upper 4 bits of which indicate the type of packet, as per RFC 1144:
            - 0x40: an unmodified IP datagram (TYPE_IP); 
            - 0x70: an uncompressed-TCP IP datagram (UNCOMPRESSED_TCP), with that byte being the first byte of the raw IP header on the wire, containing the connection number in the protocol field; 
            - 0x80: a compressed-TCP IP datagram (COMPRESSED_TCP), with that byte being the first byte of the compressed TCP/IP datagram header; 
        -# for UNCOMPRESSED_TCP, the rest of the modified IP header, and for COMPRESSED_TCP, the compressed TCP/IP datagram header; 
        -# for a total of 16 bytes; the uncompressed IP datagram follows the header. 

- DLT_PPP: PPP; if the first 2 bytes are 0xff and 0x03, it's PPP in HDLC-like framing, with the PPP header following those two bytes, otherwise it's PPP without framing, and the packet begins with the PPP header. 
- DLT_FDDI: FDDI 
- DLT_ATM_RFC1483: RFC 1483 LLC/SNAP-encapsulated ATM; the packet begins with an IEEE 802.2 LLC header. 
- DLT_RAW: raw IP; the packet begins with an IP header. 
- DLT_PPP_SERIAL: PPP in HDLC-like framing, as per RFC 1662, or Cisco PPP with HDLC framing, as per section 4.3.1 of RFC 1547; the first byte will be 0xFF for PPP in HDLC-like framing, and will be 0x0F or 0x8F for Cisco PPP with HDLC framing. 
- DLT_PPP_ETHER: PPPoE; the packet begins with a PPPoE header, as per RFC 2516. 
- DLT_C_HDLC: Cisco PPP with HDLC framing, as per section 4.3.1 of RFC 1547. 
- DLT_IEEE802_11: IEEE 802.11 wireless LAN 
- DLT_FRELAY: Frame Relay 
- DLT_LOOP: OpenBSD loopback encapsulation; the link layer header is a 4-byte field, in network byte order, containing a PF_ value from OpenBSD's socket.h for the network-layer protocol of the packet. 
    Note that, if a ``savefile'' is being read, those PF_ values are not necessarily those of the machine reading the capture file. 
- DLT_LINUX_SLL: Linux "cooked" capture encapsulation; the link layer header contains, in order:
    - a 2-byte "packet type", in network byte order, which is one of:
        -# packet was sent to us by somebody else 
        -# packet was broadcast by somebody else 
        -# packet was multicast, but not broadcast, by somebody else 
        -# packet was sent by somebody else to somebody else 
        -# packet was sent by us 
    - a 2-byte field, in network byte order, containing a Linux ARPHRD_ value for the link layer device type;
    - a 2-byte field, in network byte order, containing the length of the link layer address of the sender of the packet (which could be 0);
    - an 8-byte field containing that number of bytes of the link layer header (if there are more than 8 bytes, only the first 8 are present);
    - 2-byte field containing an Ethernet protocol type, in network byte order, or containing 1 for Novell 802.3 frames without an 802.2 LLC header or 4 for frames beginning with an 802.2 LLC header. 
- DLT_LTALK: Apple LocalTalk; the packet begins with an AppleTalk LLAP header. 
- DLT_PFLOG: OpenBSD pflog; the link layer header contains, in order:
    - a 4-byte PF_ value, in network byte order;
    - a 16-character interface name;
    - a 2-byte rule number, in network byte order;
    - a 2-byte reason code, in network byte order, which is one of:
        -# match 
        -# bad offset 
        -# fragment 
        -# short 
        -# normalize 
        -# memory
    -a 2-byte action code, in network byte order, which is one of:
        -# passed 
        -# dropped 
        -# scrubbed 
    - a 2-byte direction, in network byte order, which is one of:
        -# incoming or outgoing 
        -# incoming 
        -# outgoing 
- DLT_PRISM_HEADER: Prism monitor mode information followed by an 802.11 header. 
- DLT_IP_OVER_FC: RFC 2625 IP-over-Fibre Channel, with the link-layer header being the Network_Header as described in that RFC. 
- DLT_SUNATM: SunATM devices; the link layer header contains, in order:
    - a 1-byte flag field, containing a direction flag in the uppermost bit, which is set for packets transmitted by the machine and clear for packets received by the machine, and a 4-byte traffic type in the low-order 4 bits, which is one of:
        -# raw traffic 
        -# LANE traffic 
        -# LLC-encapsulated traffic 
        -# MARS traffic 
        -# IFMP traffic 
        -# ILMI traffic 
        -# Q.2931 traffic 
    - a 1-byte VPI value;
    - a 2-byte VCI field, in network byte order. 
- DLT_IEEE802_11_RADIO: link-layer information followed by an 802.11 header - see http://www.radiotap.org/ for a description of the link-layer information. 
- DLT_ARCNET_LINUX: ARCNET, with no exception frames, reassembled packets rather than raw frames, and an extra 16-bit offset field between the destination host and type bytes. 
- DLT_LINUX_IRDA: Linux-IrDA packets, with a DLT_LINUX_SLL header followed by the IrLAP header. 
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga64e482360b0ed7d65fce1db23d56b921" title="list datalinks ">pcap_list_datalinks()</a>, <a class="el" href="group__wpcapfunc.html#ga9588b99ac118cf827873d9e941eb6c77" title="Set the current data link type of the pcap descriptor to the type specified by dlt. -1 is returned on failure. ">pcap_set_datalink()</a>, <a class="el" href="group__wpcapfunc.html#ga440b2f0757acd4804588933324909207" title="Translates a data link type name, which is a DLT_ name with the DLT_ removed, to the corresponding da...">pcap_datalink_name_to_val()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga440b2f0757acd4804588933324909207"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_datalink_name_to_val </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates a data link type name, which is a DLT_ name with the DLT_ removed, to the corresponding data link type value. The translation is case-insensitive. -1 is returned on failure. </p>

</div>
</div>
<a class="anchor" id="ga3f142cd0694b49357e4a73371db71411"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pcap_datalink_val_to_description </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dlt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates a data link type value to a short description of that data link type. NULL is returned on failure. </p>

</div>
</div>
<a class="anchor" id="gad45c16d494577f1886704af8f31ed442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pcap_datalink_val_to_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dlt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates a data link type value to the corresponding data link type name. NULL is returned on failure. </p>

</div>
</div>
<a class="anchor" id="ga60ce104cdf28420d3361cd36d15be44c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__wpcapfunc.html#gabcba231c099919ecd9300d7160b19878">pcap_handler</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_char *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a group of packets. </p>
<p><a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> is used to collect and process packets. cnt specifies the maximum number of packets to process before returning. This is not a minimum number; when reading a live capture, only one bufferful of packets is read at a time, so fewer than cnt packets may be processed. A cnt of -1 processes all the packets received in one buffer when reading a live capture, or all the packets in the file when reading a ``savefile''. callback specifies a routine to be called with three arguments: a u_char pointer which is passed in from <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a>, a const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> pointer, and a const u_char pointer to the first caplen (as given in the struct <a class="el" href="structpcap__pkthdr.html" title="Header of a packet in the dump file. ">pcap_pkthdr</a> a pointer to which is passed to the callback routine) bytes of data from the packet (which won't necessarily be the entire packet; to capture the entire packet, you will have to provide a value for snaplen in your call to <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> that is sufficiently large to get all of the packet's data - a value of 65535 should be sufficient on most if not all networks).</p>
<p>The number of packets read is returned. 0 is returned if no packets were read from a live capture (if, for example, they were discarded because they didn't pass the packet filter, or if, on platforms that support a read timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read) or if no more packets are available in a ``savefile.'' A return of -1 indicates an error in which case <a class="el" href="group__wpcapfunc.html#gac3b6784c6c2623b93b22f6f219bd470e" title="print the text of the last pcap library error on stderr, prefixed by prefix. ">pcap_perror()</a> or <a class="el" href="group__wpcapfunc.html#ga81305cb154e4497e95bbb9b708631a3a" title="return the error text pertaining to the last pcap library error. ">pcap_geterr()</a> may be used to display the error text. A return of -2 indicates that the loop terminated due to a call to <a class="el" href="group__wpcapfunc.html#gae0dc50910fabbd375fab8a1352a6cf33" title="set a flag that will force pcap_dispatch() or pcap_loop() to return rather than looping. ">pcap_breakloop()</a> before any packets were processed. If your application uses <a class="el" href="group__wpcapfunc.html#gae0dc50910fabbd375fab8a1352a6cf33" title="set a flag that will force pcap_dispatch() or pcap_loop() to return rather than looping. ">pcap_breakloop()</a>, make sure that you explicitly check for -1 and -2, rather than just checking for a return value &lt; 0.</p>
<dl class="section note"><dt>Note</dt><dd>when reading a live capture, <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> will not necessarily return when the read times out; on some platforms, the read timeout isn't supported, and, on other platforms, the timer doesn't start until at least one packet arrives. This means that the read timeout should NOT be used in, for example, an interactive application, to allow the packet capture loop to ``poll'' for user input periodically, as there's no guarantee that <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> will return after the timeout expires.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a>, <a class="el" href="group__wpcapfunc.html#gadf60257f650aaf869671e0a163611fc3" title="Return the next available packet. ">pcap_next()</a>, <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga91078168a13de8848df2b7b83d1f5b69" title="Open a savefile in the tcpdump/libpcap format to read packets. ">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#gabcba231c099919ecd9300d7160b19878" title="Prototype of the callback function that receives the packets. ">pcap_handler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga659439bf5aa3988b5a92d31990fbf437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcap_dump </td>
          <td>(</td>
          <td class="paramtype">u_char *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u_char *&#160;</td>
          <td class="paramname"><em>sp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a packet to disk. </p>
<p><a class="el" href="group__wpcapfunc.html#ga659439bf5aa3988b5a92d31990fbf437" title="Save a packet to disk. ">pcap_dump()</a> outputs a packet to the "savefile" opened with <a class="el" href="group__wpcapfunc.html#ga9506c33d580fdb5e5c288dba0f8a085c" title="Open a file to write packets. ">pcap_dump_open()</a>. Note that its calling arguments are suitable for use with <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a>. If called directly, the user parameter is of type pcap_dumper_t as returned by <a class="el" href="group__wpcapfunc.html#ga9506c33d580fdb5e5c288dba0f8a085c" title="Open a file to write packets. ">pcap_dump_open()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga9506c33d580fdb5e5c288dba0f8a085c" title="Open a file to write packets. ">pcap_dump_open()</a>, <a class="el" href="group__wpcapfunc.html#ga3897795c1e9fb10571092febae964ef0" title="Closes a savefile. ">pcap_dump_close()</a>, <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a>, <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3897795c1e9fb10571092febae964ef0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcap_dump_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#gab8c7858aa3a7e3158d9d58cb113a2ae8">pcap_dumper_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a savefile. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga9506c33d580fdb5e5c288dba0f8a085c" title="Open a file to write packets. ">pcap_dump_open()</a>, <a class="el" href="group__wpcapfunc.html#ga659439bf5aa3988b5a92d31990fbf437" title="Save a packet to disk. ">pcap_dump()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8dac02f297422ff2ab5983d1e30c58b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* pcap_dump_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#gab8c7858aa3a7e3158d9d58cb113a2ae8">pcap_dumper_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the standard I/O stream of the 'savefile' opened by <a class="el" href="group__wpcapfunc.html#ga9506c33d580fdb5e5c288dba0f8a085c" title="Open a file to write packets. ">pcap_dump_open()</a>. </p>

</div>
</div>
<a class="anchor" id="ga90404ae3dcffcd3bbe78f8b187a88984"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_dump_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#gab8c7858aa3a7e3158d9d58cb113a2ae8">pcap_dumper_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the output buffer to the <code>savefile,'' so that any packets written with <a class="el" href="group__wpcapfunc.html#ga659439bf5aa3988b5a92d31990fbf437" title="Save a packet to disk. ">pcap_dump()</a> but not yet written to the</code>savefile'' will be written. -1 is returned on error, 0 on success. </p>

</div>
</div>
<a class="anchor" id="ga50de34b8b3298f76c66c82b7ca3f84de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long pcap_dump_ftell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#gab8c7858aa3a7e3158d9d58cb113a2ae8">pcap_dumper_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the file position for a "savefile". </p>
<p><a class="el" href="group__wpcapfunc.html#ga50de34b8b3298f76c66c82b7ca3f84de" title="Return the file position for a &quot;savefile&quot;. ">pcap_dump_ftell()</a> returns the current file position for the "savefile", representing the number of bytes written by <a class="el" href="group__wpcapfunc.html#ga9506c33d580fdb5e5c288dba0f8a085c" title="Open a file to write packets. ">pcap_dump_open()</a> and <a class="el" href="group__wpcapfunc.html#ga659439bf5aa3988b5a92d31990fbf437" title="Save a packet to disk. ">pcap_dump()</a> . -1 is returned on error.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga9506c33d580fdb5e5c288dba0f8a085c" title="Open a file to write packets. ">pcap_dump_open()</a>, <a class="el" href="group__wpcapfunc.html#ga659439bf5aa3988b5a92d31990fbf437" title="Save a packet to disk. ">pcap_dump()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9506c33d580fdb5e5c288dba0f8a085c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__wpcap__def.html#gab8c7858aa3a7e3158d9d58cb113a2ae8">pcap_dumper_t</a>* pcap_dump_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file to write packets. </p>
<p><a class="el" href="group__wpcapfunc.html#ga9506c33d580fdb5e5c288dba0f8a085c" title="Open a file to write packets. ">pcap_dump_open()</a> is called to open a "savefile" for writing. The name "-" in a synonym for stdout. NULL is returned on failure. p is a pcap struct as returned by <a class="el" href="group__wpcapfunc.html#ga91078168a13de8848df2b7b83d1f5b69" title="Open a savefile in the tcpdump/libpcap format to read packets. ">pcap_open_offline()</a> or <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>. fname specifies the name of the file to open. Alternatively, you may call pcap_dump_fopen() to write data to an existing open stream fp. Note that on Windows, that stream should be opened in binary mode. If NULL is returned, <a class="el" href="group__wpcapfunc.html#ga81305cb154e4497e95bbb9b708631a3a" title="return the error text pertaining to the last pcap library error. ">pcap_geterr()</a> can be used to get the error text.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga3897795c1e9fb10571092febae964ef0" title="Closes a savefile. ">pcap_dump_close()</a>, <a class="el" href="group__wpcapfunc.html#ga659439bf5aa3988b5a92d31990fbf437" title="Save a packet to disk. ">pcap_dump()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c9f5690b99fb2af1f8904403f7da06b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* pcap_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the standard stream of an offline capture. </p>
<p><a class="el" href="group__wpcapfunc.html#ga4c9f5690b99fb2af1f8904403f7da06b" title="Return the standard stream of an offline capture. ">pcap_file()</a> returns the standard I/O stream of the "savefile", if a "savefile" was opened with <a class="el" href="group__wpcapfunc.html#ga91078168a13de8848df2b7b83d1f5b69" title="Open a savefile in the tcpdump/libpcap format to read packets. ">pcap_open_offline()</a>, or NULL, if a network device was opened with <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Due to incompatibilities between the C Runtime (CRT) used to compile WinPcap and the one used by WinPcap-based applications, this function may return an invalid FILE pointer, i.e. a descriptor that causes all the standard I/O stream functions (ftell, fseek, fclose...) to fail. The function is still available for backwards binary compatibility, only.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga91078168a13de8848df2b7b83d1f5b69" title="Open a savefile in the tcpdump/libpcap format to read packets. ">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b128eaeef627b408f6a6e2a2f5eb45d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_findalldevs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga3a6e7cbf8d9752da3add4676c7cd4c58">pcap_if_t</a> **&#160;</td>
          <td class="paramname"><em>alldevsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a list of network devices that can be opened with <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>that there may be network devices that cannot be opened with <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> by the process calling <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a>, because, for example, that process might not have sufficient privileges to open them for capturing; if so, those devices will not appear on the list.) alldevsp is set to point to the first element of the list; each element of the list is of type <a class="el" href="group__wpcap__def.html#ga3a6e7cbf8d9752da3add4676c7cd4c58">pcap_if_t</a>,</dd></dl>
<p>-1 is returned on failure, in which case errbuf is filled in with an appropriate error message; 0 is returned on success.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structpcap__if.html" title="Item in a list of interfaces, used by pcap_findalldevs(). ">pcap_if</a>, <a class="el" href="group__wpcapfunc.html#ga346b4b0b7fd1cda4abb9a39f767dbeb1" title="Free an interface list returned by pcap_findalldevs(). ">pcap_freealldevs()</a>, <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#gaed295fc9fd86434372e8a8316f1270b1" title="Return the first valid device in the system. ">pcap_lookupdev()</a>, <a class="el" href="group__wpcapfunc.html#gaa35276d0fa530c51a455f298fa1ec453" title="Return the subnet and netmask of an interface. ">pcap_lookupnet()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga98f36e62c95c6ad81eaa8b2bbeb8f16e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_findalldevs_ex </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct pcap_rmtauth *&#160;</td>
          <td class="paramname"><em>auth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga3a6e7cbf8d9752da3add4676c7cd4c58">pcap_if_t</a> **&#160;</td>
          <td class="paramname"><em>alldevs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a list of network devices that can be opened with <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a>. </p>
<p>This function is a superset of the old '<a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a>', which allows listing only the devices present on the local machine. Vice versa, <a class="el" href="group__wpcapfunc.html#ga98f36e62c95c6ad81eaa8b2bbeb8f16e" title="Create a list of network devices that can be opened with pcap_open(). ">pcap_findalldevs_ex()</a> allows listing the devices present on a remote machine as well. Additionally, it can list all the pcap files available into a given folder. Moreover, <a class="el" href="group__wpcapfunc.html#ga98f36e62c95c6ad81eaa8b2bbeb8f16e" title="Create a list of network devices that can be opened with pcap_open(). ">pcap_findalldevs_ex()</a> is platform independent, since it relies on the standard <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a> to get addresses on the local machine.</p>
<p>In case the function has to list the interfaces on a remote machine, it opens a new control connection toward that machine, it retrieves the interfaces, and it drops the connection. However, if this function detects that the remote machine is in 'active' mode, the connection is not dropped and the existing socket is used.</p>
<p>The 'source' is a parameter that tells the function where the lookup has to be done and it uses the same syntax of the <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a>.</p>
<p>Differently from the <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a>, the interface names (pointed by the alldevs-&gt;name and the other ones in the linked list) are already ready to be used in the <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a> call. Vice versa, the output that comes from <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a> must be formatted with the new <a class="el" href="group__wpcapfunc.html#gaa3111e10f930a9772a32a922b26948b0" title="Accept a set of strings (host name, port, ...), and it returns the complete source string according t...">pcap_createsrcstr()</a> before passing the source identifier to the <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>a char* buffer that keeps the 'source localtion', according to the new WinPcap syntax. This source will be examined looking for adapters (local or remote) (e.g. source can be 'rpcap://' for local adapters or 'rpcap://host:port' for adapters on a remote host) or pcap files (e.g. source can be '<a href="file://c:/myfolder/'">file://c:/myfolder/'</a>).<br />
 The strings that must be prepended to the 'source' in order to define if we want local/remote adapters or files is defined in the new <a class="el" href="group__remote__source__string.html">Source Specification Syntax </a>.</td></tr>
    <tr><td class="paramname">auth</td><td>a pointer to a pcap_rmtauth structure. This pointer keeps the information required to authenticate the RPCAP connection to the remote host. This parameter is not meaningful in case of a query to the local host: in that case it can be NULL.</td></tr>
    <tr><td class="paramname">alldevs</td><td>a 'struct pcap_if_t' pointer, which will be properly allocated inside this function. When the function returns, it is set to point to the first element of the interface list; each element of the list is of type 'struct pcap_if_t'.</td></tr>
    <tr><td class="paramname">errbuf</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'0' if everything is fine, '-1' if some errors occurred. The list of the devices is returned in the 'alldevs' variable. When the function returns correctly, 'alldevs' cannot be NULL. In other words, this function returns '-1' also in case the system does not have any interface to list.</dd></dl>
<p>The error message is returned in the 'errbuf' variable. An error could be due to several reasons:</p><ul>
<li>libpcap/WinPcap was not installed on the local/remote host</li>
<li>the user does not have enough privileges to list the devices / files</li>
<li>a network problem</li>
<li>the RPCAP version negotiation failed</li>
<li>other errors (not enough memory and others).</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>There may be network devices that cannot be opened with <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a> by the process calling <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a>, because, for example, that process might not have sufficient privileges to open them for capturing; if so, those devices will not appear on the list.</dd>
<dd>
The interface list must be deallocated manually by using the <a class="el" href="group__wpcapfunc.html#ga346b4b0b7fd1cda4abb9a39f767dbeb1" title="Free an interface list returned by pcap_findalldevs(). ">pcap_freealldevs()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga346b4b0b7fd1cda4abb9a39f767dbeb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcap_freealldevs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga3a6e7cbf8d9752da3add4676c7cd4c58">pcap_if_t</a> *&#160;</td>
          <td class="paramname"><em>alldevsp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an interface list returned by <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a>. </p>
<p><a class="el" href="group__wpcapfunc.html#ga346b4b0b7fd1cda4abb9a39f767dbeb1" title="Free an interface list returned by pcap_findalldevs(). ">pcap_freealldevs()</a> is used to free a list allocated by <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e0a5aad1a5dc79d85f1edfcebe0ac13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcap_freecode </td>
          <td>(</td>
          <td class="paramtype">struct bpf_program *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a filter. </p>
<p><a class="el" href="group__wpcapfunc.html#ga9e0a5aad1a5dc79d85f1edfcebe0ac13" title="Free a filter. ">pcap_freecode()</a> is used to free up allocated memory pointed to by a bpf_program struct generated by <a class="el" href="group__wpcapfunc.html#ga363bdc6f6b39b4979ddcf15ecb830c5c" title="Compile a packet filter, converting an high level filtering expression (see Filtering expression synt...">pcap_compile()</a> when that BPF program is no longer needed, for example after it has been made the filter program for a pcap structure by a call to <a class="el" href="group__wpcapfunc.html#gaf5f9cfe85dad0967ff607e5159b1ba61" title="Associate a filter to a capture. ">pcap_setfilter()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga363bdc6f6b39b4979ddcf15ecb830c5c" title="Compile a packet filter, converting an high level filtering expression (see Filtering expression synt...">pcap_compile()</a>, <a class="el" href="group__wpcapfunc.html#ga8325b202dad14a00609db8372722ae4e" title="Compile a packet filter without the need of opening an adapter. This function converts an high level ...">pcap_compile_nopcap()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c8f8d1b9238c74faa156494a6b98670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Win32-Extensions_8h.html#aadfdcc0e37082d8f6b28a43ec9a0bccf">PAirpcapHandle</a> pcap_get_airpcap_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the AirPcap handler associated with an adapter. This handler can be used to change the wireless-related settings of the CACE Technologies AirPcap wireless capture adapters. </p>
<dl class="section note"><dt>Note</dt><dd>THIS FUNCTION SHOULD BE CONSIDERED PROVISIONAL, AND MAY BE REPLACED IN THE FUTURE BY A MORE COMPLETE SET OF FUNCTIONS FOR WIRELESS SUPPORT.</dd></dl>
<p><a class="el" href="group__wpcapfunc.html#ga4c8f8d1b9238c74faa156494a6b98670" title="Returns the AirPcap handler associated with an adapter. This handler can be used to change the wirele...">pcap_get_airpcap_handle()</a> allows to obtain the airpcap handle of an open adapter. This handle can be used with the AirPcap API functions to perform wireless-releated operations, e.g. changing the channel or enabling WEP decryption. For more details about the AirPcap wireless capture adapters, see <a href="http://www.cacetech.com/products/airpcap.html">http://www.cacetech.com/products/airpcap.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>handle to an open libpcap adapter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an open AirPcap handle, used internally by the libpcap open adapter. NULL if the libpcap adapter doesn't have wireless support through AirPcap. </dd></dl>

</div>
</div>
<a class="anchor" id="ga81305cb154e4497e95bbb9b708631a3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pcap_geterr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the error text pertaining to the last pcap library error. </p>
<dl class="section note"><dt>Note</dt><dd>the pointer Return will no longer point to a valid error message string after the pcap_t passed to it is closed; you must use or copy the string before closing the pcap_t.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gac3b6784c6c2623b93b22f6f219bd470e" title="print the text of the last pcap library error on stderr, prefixed by prefix. ">pcap_perror()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c415e9192c7b18a81a02300ae6f2c02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE pcap_getevent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the handle of the event associated with the interface p. </p>
<p>This event can be passed to functions like WaitForSingleObject() or WaitForMultipleObjects() to wait until the driver's buffer contains some data without performing a read.</p>
<p>We disourage the use of this function because it is not portable.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab25dc0bfe06545b86be4103bf010708e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_getnonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the "non-blocking" state of an interface. </p>
<p><a class="el" href="group__wpcapfunc.html#gab25dc0bfe06545b86be4103bf010708e" title="Get the &quot;non-blocking&quot; state of an interface. ">pcap_getnonblock()</a> returns the current "non-blocking" state of the capture descriptor; it always returns 0 on "savefiles". If there is an error, -1 is returned and errbuf is filled in with an appropriate error message.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga3f212141c80b59aad8ac535bb0178275" title="Switch between blocking and nonblocking mode. ">pcap_setnonblock()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaba4941e09e5e03ba39841de4b1d5d6a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_is_swapped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the current savefile uses a different byte order than the current system. </p>

</div>
</div>
<a class="anchor" id="ga2d92cec9ff55906b5b6fb883e4bd72f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pcap_lib_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a string giving information about the version of the libpcap library being used; note that it contains more information than just a version number. </p>

</div>
</div>
<a class="anchor" id="ga64e482360b0ed7d65fce1db23d56b921"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_list_datalinks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>dlt_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>list datalinks </p>
<p><a class="el" href="group__wpcapfunc.html#ga64e482360b0ed7d65fce1db23d56b921" title="list datalinks ">pcap_list_datalinks()</a> is used to get a list of the supported data link types of the interface associated with the pcap descriptor. <a class="el" href="group__wpcapfunc.html#ga64e482360b0ed7d65fce1db23d56b921" title="list datalinks ">pcap_list_datalinks()</a> allocates an array to hold the list and sets *dlt_buf. The caller is responsible for freeing the array. -1 is returned on failure; otherwise, the number of data link types in the array is returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga64c019f851f7da6892d51cca15f12ace" title="Return the link layer of an adapter. ">pcap_datalink()</a>, <a class="el" href="group__wpcapfunc.html#ga9588b99ac118cf827873d9e941eb6c77" title="Set the current data link type of the pcap descriptor to the type specified by dlt. -1 is returned on failure. ">pcap_set_datalink()</a>, <a class="el" href="group__wpcapfunc.html#ga440b2f0757acd4804588933324909207" title="Translates a data link type name, which is a DLT_ name with the DLT_ removed, to the corresponding da...">pcap_datalink_name_to_val()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaedef54159d918b22a7de8e75b8a3ef4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_live_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxpacks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a capture to file. </p>
<dl class="section note"><dt>Note</dt><dd>: this function does not work in current version of WinPcap.</dd></dl>
<p><a class="el" href="group__wpcapfunc.html#gaedef54159d918b22a7de8e75b8a3ef4d" title="Save a capture to file. ">pcap_live_dump()</a> dumps the network traffic from an interface to a file. Using this function the dump is performed at kernel level, therefore it is more efficient than using <a class="el" href="group__wpcapfunc.html#ga659439bf5aa3988b5a92d31990fbf437" title="Save a packet to disk. ">pcap_dump()</a>.</p>
<p>The parameters of this function are an interface descriptor (obtained with <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>), a string with the name of the dump file, the maximum size of the file (in bytes) and the maximum number of packets that the file will contain. Setting maxsize or maxpacks to 0 means no limit. When maxsize or maxpacks are reached, the dump ends.</p>
<p><a class="el" href="group__wpcapfunc.html#gaedef54159d918b22a7de8e75b8a3ef4d" title="Save a capture to file. ">pcap_live_dump()</a> is non-blocking, threfore Return immediately. <a class="el" href="group__wpcapfunc.html#gafe8a334f3a7ae2dc7f52e96523da39be" title="Return the status of the kernel dump process, i.e. tells if one of the limits defined with pcap_live_...">pcap_live_dump_ended()</a> can be used to check the status of the dump process or to wait until it is finished. <a class="el" href="group__wpcapfunc.html#gaa45a5e1a4ba9925bb3586dcbeec78560" title="close the files associated with p and deallocates resources. ">pcap_close()</a> can instead be used to end the dump process.</p>
<p>Note that when one of the two limits is reached, the dump is stopped, but the file remains opened. In order to correctly flush the data and put the file in a consistent state, the adapter must be closed with <a class="el" href="group__wpcapfunc.html#gaa45a5e1a4ba9925bb3586dcbeec78560" title="close the files associated with p and deallocates resources. ">pcap_close()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gafe8a334f3a7ae2dc7f52e96523da39be" title="Return the status of the kernel dump process, i.e. tells if one of the limits defined with pcap_live_...">pcap_live_dump_ended()</a>, <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#gaa45a5e1a4ba9925bb3586dcbeec78560" title="close the files associated with p and deallocates resources. ">pcap_close()</a>, <a class="el" href="group__wpcapfunc.html#ga9506c33d580fdb5e5c288dba0f8a085c" title="Open a file to write packets. ">pcap_dump_open()</a>, <a class="el" href="group__wpcapfunc.html#ga659439bf5aa3988b5a92d31990fbf437" title="Save a packet to disk. ">pcap_dump()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafe8a334f3a7ae2dc7f52e96523da39be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_live_dump_ended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the kernel dump process, i.e. tells if one of the limits defined with <a class="el" href="group__wpcapfunc.html#gaedef54159d918b22a7de8e75b8a3ef4d" title="Save a capture to file. ">pcap_live_dump()</a> has been reached. </p>
<dl class="section note"><dt>Note</dt><dd>: this function does not work in current version of WinPcap.</dd></dl>
<p><a class="el" href="group__wpcapfunc.html#gafe8a334f3a7ae2dc7f52e96523da39be" title="Return the status of the kernel dump process, i.e. tells if one of the limits defined with pcap_live_...">pcap_live_dump_ended()</a> informs the user about the limits that were set with a previous call to <a class="el" href="group__wpcapfunc.html#gaedef54159d918b22a7de8e75b8a3ef4d" title="Save a capture to file. ">pcap_live_dump()</a> on the interface pointed by p: if the return value is nonzero, one of the limits has been reched and the dump process is currently stopped.</p>
<p>If sync is nonzero, the function blocks until the dump is finished, otherwise Return immediately.</p>
<dl class="section warning"><dt>Warning</dt><dd>if the dump process has no limits (i.e. if the maxsize and maxpacks arguments of <a class="el" href="group__wpcapfunc.html#gaedef54159d918b22a7de8e75b8a3ef4d" title="Save a capture to file. ">pcap_live_dump()</a> were both 0), the dump process will never stop, therefore setting sync to TRUE will block the application on this call forever.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gaedef54159d918b22a7de8e75b8a3ef4d" title="Save a capture to file. ">pcap_live_dump()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaed295fc9fd86434372e8a8316f1270b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pcap_lookupdev </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first valid device in the system. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d">pcap_findalldevs()</a> or <a class="el" href="group__wpcapfunc.html#ga98f36e62c95c6ad81eaa8b2bbeb8f16e">pcap_findalldevs_ex()</a> instead.</dd></dl>
<pre class="fragment">   pcap_lookupdev() returns a pointer  to  a  network  device
   suitable  for  use  with pcap_open_live() and pcap_lookupnet().
   If there is an error, NULL is returned and  errbuf
   is filled in with an appropriate error message.
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a>, <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa35276d0fa530c51a455f298fa1ec453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_lookupnet </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga37fdbc8313e90fb2041203a2e40cd482">bpf_u_int32</a> *&#160;</td>
          <td class="paramname"><em>netp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga37fdbc8313e90fb2041203a2e40cd482">bpf_u_int32</a> *&#160;</td>
          <td class="paramname"><em>maskp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the subnet and netmask of an interface. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d">pcap_findalldevs()</a> or <a class="el" href="group__wpcapfunc.html#ga98f36e62c95c6ad81eaa8b2bbeb8f16e">pcap_findalldevs_ex()</a> instead.</dd></dl>
<pre class="fragment">   pcap_lookupnet()  is  used to determine the network number
   and mask associated with the network device device.   Both
   netp  and  maskp are bpf_u_int32 pointers.  A return of -1
   indicates an error in which case errbuf is filled in  with
   an appropriate error message.
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6bcb7c5c59d76ec16b8a699da136b5de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__wpcapfunc.html#gabcba231c099919ecd9300d7160b19878">pcap_handler</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_char *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a group of packets. </p>
<p><a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a> is similar to <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> except it keeps reading packets until cnt packets are processed or an error occurs. It does not return when live read timeouts occur. Rather, specifying a non-zero read timeout to <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> and then calling <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> allows the reception and processing of any packets that arrive when the timeout occurs. A negative cnt causes <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a> to loop forever (or at least until an error occurs). -1 is returned on an error; 0 is returned if cnt is exhausted; -2 is returned if the loop terminated due to a call to <a class="el" href="group__wpcapfunc.html#gae0dc50910fabbd375fab8a1352a6cf33" title="set a flag that will force pcap_dispatch() or pcap_loop() to return rather than looping. ">pcap_breakloop()</a> before any packets were processed. If your application uses <a class="el" href="group__wpcapfunc.html#gae0dc50910fabbd375fab8a1352a6cf33" title="set a flag that will force pcap_dispatch() or pcap_loop() to return rather than looping. ">pcap_breakloop()</a>, make sure that you explicitly check for -1 and -2, rather than just checking for a return value &lt; 0.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a>, <a class="el" href="group__wpcapfunc.html#gadf60257f650aaf869671e0a163611fc3" title="Return the next available packet. ">pcap_next()</a>, <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga91078168a13de8848df2b7b83d1f5b69" title="Open a savefile in the tcpdump/libpcap format to read packets. ">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#gabcba231c099919ecd9300d7160b19878" title="Prototype of the callback function that receives the packets. ">pcap_handler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga39dfb05149b443cc25b8febc455ca753"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_major_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the major version number of the pcap library used to write the savefile. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gac7a9dd9cd040ee500221cf35dfb49248" title="return the minor version number of the pcap library used to write the savefile. ">pcap_minor_version()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac7a9dd9cd040ee500221cf35dfb49248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_minor_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the minor version number of the pcap library used to write the savefile. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga39dfb05149b443cc25b8febc455ca753" title="return the major version number of the pcap library used to write the savefile. ">pcap_major_version()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadf60257f650aaf869671e0a163611fc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_char* pcap_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next available packet. </p>
<p><a class="el" href="group__wpcapfunc.html#gadf60257f650aaf869671e0a163611fc3" title="Return the next available packet. ">pcap_next()</a> reads the next packet (by calling <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> with a cnt of 1) and returns a u_char pointer to the data in that packet. (The <a class="el" href="structpcap__pkthdr.html" title="Header of a packet in the dump file. ">pcap_pkthdr</a> struct for that packet is not supplied.) NULL is returned if an error occured, or if no packets were read from a live capture (if, for example, they were discarded because they didn't pass the packet filter, or if, on platforms that support a read timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read), or if no more packets are available in a ``savefile.'' Unfortunately, there is no way to determine whether an error occured or not. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a>, <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga439439c2eae61161dc1efb1e03a81133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_next_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> **&#160;</td>
          <td class="paramname"><em>pkt_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u_char **&#160;</td>
          <td class="paramname"><em>pkt_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a packet from an interface or from an offline capture. </p>
<p>This function is used to retrieve the next available packet, bypassing the callback method traditionally provided by libpcap.</p>
<p>pcap_next_ex fills the pkt_header and pkt_data parameters (see <a class="el" href="group__wpcapfunc.html#gabcba231c099919ecd9300d7160b19878" title="Prototype of the callback function that receives the packets. ">pcap_handler()</a>) with the pointers to the header and to the data of the next captured packet.</p>
<p>The return value can be:</p><ul>
<li>1 if the packet has been read without problems</li>
<li>0 if the timeout set with <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> has elapsed. In this case pkt_header and pkt_data don't point to a valid packet</li>
<li>-1 if an error occurred</li>
<li>-2 if EOF was reached reading from an offline capture</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a>, <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a>, <a class="el" href="group__wpcapfunc.html#gabcba231c099919ecd9300d7160b19878" title="Prototype of the callback function that receives the packets. ">pcap_handler()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae92f11bfb001c19b2d0fbcd6821d222a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_offline_filter </td>
          <td>(</td>
          <td class="paramtype">struct bpf_program *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u_char *&#160;</td>
          <td class="paramname"><em>pkt_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if a given filter applies to an offline packet. </p>
<p>This function is used to apply a filter to a packet that is currently in memory. This process does not need to open an adapter; we need just to create the proper filter (by settings parameters like the snapshot length, or the link-layer type) by means of the <a class="el" href="group__wpcapfunc.html#ga8325b202dad14a00609db8372722ae4e" title="Compile a packet filter without the need of opening an adapter. This function converts an high level ...">pcap_compile_nopcap()</a>.</p>
<p>The current API of libpcap does not allow to receive a packet and to filter the packet after it has been received. However, this can be useful in case you want to filter packets in the application, instead of into the receiving process. This function allows you to do the job.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>bpf program (created with the <a class="el" href="group__wpcapfunc.html#ga8325b202dad14a00609db8372722ae4e" title="Compile a packet filter without the need of opening an adapter. This function converts an high level ...">pcap_compile_nopcap()</a> ) </td></tr>
    <tr><td class="paramname">header</td><td>header of the packet that has to be filtered </td></tr>
    <tr><td class="paramname">pkt_data</td><td>buffer containing the packet, in network-byte order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the bytes that are currently available into the packet if the packet satisfies the filter, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b64c7b6490090d1d37088794f1f1791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a>* pcap_open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>snaplen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct pcap_rmtauth *&#160;</td>
          <td class="paramname"><em>auth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a generic source in order to capture / send (WinPcap only) traffic. </p>
<p>The <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a> replaces all the pcap_open_xxx() functions with a single call.</p>
<p>This function hides the differences between the different pcap_open_xxx() functions so that the programmer does not have to manage different opening function. In this way, the 'true' open function is decided according to the source type, which is included into the source string (in the form of source prefix).</p>
<p>This function can rely on the <a class="el" href="group__wpcapfunc.html#gaa3111e10f930a9772a32a922b26948b0" title="Accept a set of strings (host name, port, ...), and it returns the complete source string according t...">pcap_createsrcstr()</a> to create the string that keeps the capture device according to the new syntax, and the <a class="el" href="group__wpcapfunc.html#ga090e0afd3f463b4b60a64c47eddc1ba2" title="Parse the source string and returns the pieces in which the source can be split. ">pcap_parsesrcstr()</a> for the other way round.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>zero-terminated string containing the source name to open. The source name has to include the format prefix according to the new <a class="el" href="group__remote__source__string.html">Source Specification Syntax</a> and it cannot be NULL.<br />
 On on Linux systems with 2.2 or later kernels, a device argument of "any" (i.e. rpcap://any) can be used to capture packets from all interfaces. <br />
 In order to makes the source syntax easier, please remember that:<ul>
<li>the adapters returned by the <a class="el" href="group__wpcapfunc.html#ga98f36e62c95c6ad81eaa8b2bbeb8f16e" title="Create a list of network devices that can be opened with pcap_open(). ">pcap_findalldevs_ex()</a> can be used immediately by the <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a></li>
<li>in case the user wants to pass its own source string to the <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a>, the <a class="el" href="group__wpcapfunc.html#gaa3111e10f930a9772a32a922b26948b0" title="Accept a set of strings (host name, port, ...), and it returns the complete source string according t...">pcap_createsrcstr()</a> helps in creating the correct source identifier.</li>
</ul>
</td></tr>
    <tr><td class="paramname">snaplen</td><td>length of the packet that has to be retained. For each packet received by the filter, only the first 'snaplen' bytes are stored in the buffer and passed to the user application. For instance, snaplen equal to 100 means that only the first 100 bytes of each packet are stored.</td></tr>
    <tr><td class="paramname">flags</td><td>keeps several flags that can be needed for capturing packets. The allowed flags are defined in the <a class="el" href="group__remote__open__flags.html">pcap_open() flags </a>.</td></tr>
    <tr><td class="paramname">read_timeout</td><td>read timeout in milliseconds. The read timeout is used to arrange that the read not necessarily return immediately when a packet is seen, but that it waits for some amount of time to allow more packets to arrive and to read multiple packets from the OS kernel in one operation. Not all platforms support a read timeout; on platforms that don't, the read timeout is ignored.</td></tr>
    <tr><td class="paramname">auth</td><td>a pointer to a 'struct pcap_rmtauth' that keeps the information required to authenticate the user on a remote machine. In case this is not a remote capture, this pointer can be set to NULL.</td></tr>
    <tr><td class="paramname">errbuf</td><td>a pointer to a user-allocated buffer which will contain the error in case this function fails. The <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a> and findalldevs() are the only two functions which have this parameter, since they do not have (yet) a pointer to a pcap_t structure, which reserves space for the error string. Since these functions do not have (yet) a pcap_t pointer (the pcap_t pointer is NULL in case of errors), they need an explicit 'errbuf' variable. 'errbuf' may also be set to warning text when <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> succeds; to detect this case the caller should store a zero-length string in 'errbuf' before calling <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> and display the warning to the user if 'errbuf' is no longer a zero-length string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a 'pcap_t' which can be used as a parameter to the following calls (<a class="el" href="group__wpcapfunc.html#ga363bdc6f6b39b4979ddcf15ecb830c5c" title="Compile a packet filter, converting an high level filtering expression (see Filtering expression synt...">pcap_compile()</a> and so on) and that specifies an opened WinPcap session. In case of problems, it returns NULL and the 'errbuf' variable keeps the error message.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The source cannot be larger than PCAP_BUF_SIZE.</dd>
<dd>
The following formats are not allowed as 'source' strings:<ul>
<li>rpcap:// [to open the first local adapter]</li>
<li>rpcap://hostname/ [to open the first remote adapter] </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6445eeb76f2757b9fa088b276eea2845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a>* pcap_open_dead </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linktype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>snaplen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pcap_t structure without starting a capture. </p>
<p><a class="el" href="group__wpcapfunc.html#ga6445eeb76f2757b9fa088b276eea2845" title="Create a pcap_t structure without starting a capture. ">pcap_open_dead()</a> is used for creating a pcap_t structure to use when calling the other functions in libpcap. It is typically used when just using libpcap for compiling BPF code.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga91078168a13de8848df2b7b83d1f5b69" title="Open a savefile in the tcpdump/libpcap format to read packets. ">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a>, <a class="el" href="group__wpcapfunc.html#ga363bdc6f6b39b4979ddcf15ecb830c5c" title="Compile a packet filter, converting an high level filtering expression (see Filtering expression synt...">pcap_compile()</a>, <a class="el" href="group__wpcapfunc.html#gaf5f9cfe85dad0967ff607e5159b1ba61" title="Associate a filter to a capture. ">pcap_setfilter()</a>, <a class="el" href="group__wpcapfunc.html#gaa45a5e1a4ba9925bb3586dcbeec78560" title="close the files associated with p and deallocates resources. ">pcap_close()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaae6abe06e15c87b803f69773822beca8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a>* pcap_open_live </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>snaplen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>promisc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ebuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a live capture from the network. </p>
<p><a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> is used to obtain a packet capture descriptor to look at packets on the network. device is a string that specifies the network device to open; on Linux systems with 2.2 or later kernels, a device argument of "any" or NULL can be used to capture packets from all interfaces. snaplen specifies the maximum number of bytes to capture. If this value is less than the size of a packet that is captured, only the first snaplen bytes of that packet will be captured and provided as packet data. A value of 65535 should be sufficient, on most if not all networks, to capture all the data available from the packet. promisc specifies if the interface is to be put into promiscuous mode. (Note that even if this parameter is false, the interface could well be in promiscuous mode for some other reason.) For now, this doesn't work on the "any" device; if an argument of "any" or NULL is supplied, the promisc flag is ignored. to_ms specifies the read timeout in milliseconds. The read timeout is used to arrange that the read not necessarily return immediately when a packet is seen, but that it wait for some amount of time to allow more packets to arrive and to read multiple packets from the OS kernel in one operation. Not all platforms support a read timeout; on platforms that don't, the read timeout is ignored. A zero value for to_ms, on platforms that support a read timeout, will cause a read to wait forever to allow enough packets to arrive, with no timeout. errbuf is used to return error or warning text. It will be set to error text when <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> fails and returns NULL. errbuf may also be set to warning text when <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> succeds; to detect this case the caller should store a zero-length string in errbuf before calling <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> and display the warning to the user if errbuf is no longer a zero-length string.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga91078168a13de8848df2b7b83d1f5b69" title="Open a savefile in the tcpdump/libpcap format to read packets. ">pcap_open_offline()</a>, <a class="el" href="group__wpcapfunc.html#ga6445eeb76f2757b9fa088b276eea2845" title="Create a pcap_t structure without starting a capture. ">pcap_open_dead()</a>, <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a>, <a class="el" href="group__wpcapfunc.html#gaa45a5e1a4ba9925bb3586dcbeec78560" title="close the files associated with p and deallocates resources. ">pcap_close()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga91078168a13de8848df2b7b83d1f5b69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a>* pcap_open_offline </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a savefile in the tcpdump/libpcap format to read packets. </p>
<p><a class="el" href="group__wpcapfunc.html#ga91078168a13de8848df2b7b83d1f5b69" title="Open a savefile in the tcpdump/libpcap format to read packets. ">pcap_open_offline()</a> is called to open a "savefile" for reading. fname specifies the name of the file to open. The file has the same format as those used by tcpdump(1) and tcpslice(1). The name "-" in a synonym for stdin. Alternatively, you may call pcap_fopen_offline() to read dumped data from an existing open stream fp. Note that on Windows, that stream should be opened in binary mode. errbuf is used to return error text and is only set when <a class="el" href="group__wpcapfunc.html#ga91078168a13de8848df2b7b83d1f5b69" title="Open a savefile in the tcpdump/libpcap format to read packets. ">pcap_open_offline()</a> or pcap_fopen_offline() fails and returns NULL.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga9506c33d580fdb5e5c288dba0f8a085c" title="Open a file to write packets. ">pcap_dump_open()</a>, <a class="el" href="group__wpcapfunc.html#ga7b128eaeef627b408f6a6e2a2f5eb45d" title="Construct a list of network devices that can be opened with pcap_open_live(). ">pcap_findalldevs()</a>, <a class="el" href="group__wpcapfunc.html#gaa45a5e1a4ba9925bb3586dcbeec78560" title="close the files associated with p and deallocates resources. ">pcap_close()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga090e0afd3f463b4b60a64c47eddc1ba2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_parsesrcstr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the source string and returns the pieces in which the source can be split. </p>
<p>This call is the other way round of <a class="el" href="group__wpcapfunc.html#gaa3111e10f930a9772a32a922b26948b0" title="Accept a set of strings (host name, port, ...), and it returns the complete source string according t...">pcap_createsrcstr()</a>. It accepts a null-terminated string and it returns the parameters related to the source. This includes:</p><ul>
<li>the type of the source (file, winpcap on a remote adapter, winpcap on local adapter), which is determined by the source prefix (PCAP_SRC_IF_STRING and so on)</li>
<li>the host on which the capture has to be started (only for remote captures)</li>
<li>the 'raw' name of the source (file name, name of the remote adapter, name of the local adapter), without the source prefix. The string returned does not include the type of the source itself (i.e. the string returned does not include "file://" or rpcap:// or such).</li>
</ul>
<p>The user can omit some parameters in case it is not interested in them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>a null-terminated string containing the WinPcap source. This source starts with an identifier according to the new <a class="el" href="group__remote__source__string.html">Source Specification Syntax </a>.</td></tr>
    <tr><td class="paramname">type</td><td>pointer to an integer, which is used to return the code corrisponding to the selected source. The code will be one defined in the <a class="el" href="group__remote__source__ID.html">Source identification Codes </a>.<br />
 In case the source string does not exists (i.e. 'source == NULL') or it is empty ('*source == NULL'), it returns PCAP_SRC_IF_LOCAL (i.e. you are ready to call <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> ). This behavior is kept only for compatibility with older applications (e.g. tcpdump); therefore we suggest to move to the new syntax for sources.<br />
 This parameter can be NULL in case the user is not interested in that.</td></tr>
    <tr><td class="paramname">host</td><td>user-allocated buffer (of size PCAP_BUF_SIZE) that is used to return the host name on which the capture has to be started. This value is meaningful only in case of remote capture; otherwise, the returned string will be empty (""). This parameter can be NULL in case the user is not interested in that.</td></tr>
    <tr><td class="paramname">port</td><td>user-allocated buffer (of size PCAP_BUF_SIZE) that is used to return the port that has to be used by the RPCAP protocol to contact the other host. This value is meaningful only in case of remote capture and if the user wants to use a non-standard port; otherwise, the returned string will be empty (""). In case of remote capture, an emply string means "use the standard RPCAP port". This parameter can be NULL in case the user is not interested in that.</td></tr>
    <tr><td class="paramname">name</td><td>user-allocated buffer (of size PCAP_BUF_SIZE) that is used to return the source name, without the source prefix. If the name does not exist (for example because source contains 'rpcap://' that means 'default local adapter'), it returns NULL. This parameter can be NULL in case the user is not interested in that.</td></tr>
    <tr><td class="paramname">errbuf</td><td>pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one). This parameter can be NULL in case the user is not interested in that.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'0' if everything is fine, '-1' if some errors occurred. The requested values (host name, network port, type of the source) are returned into the proper variables passed by reference. </dd></dl>

</div>
</div>
<a class="anchor" id="gac3b6784c6c2623b93b22f6f219bd470e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcap_perror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print the text of the last pcap library error on stderr, prefixed by prefix. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga81305cb154e4497e95bbb9b708631a3a" title="return the error text pertaining to the last pcap library error. ">pcap_geterr()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5495943cc8262db57f726e2a23f837dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SOCKET pcap_remoteact_accept </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>connectinghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct pcap_rmtauth *&#160;</td>
          <td class="paramname"><em>auth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until a network connection is accepted (active mode only). </p>
<p>This function has been defined to allow the client dealing with the 'active mode'. In other words, in the 'active mode' the server opens the connection toward the client, so that the client has to open a socket in order to wait for connections. When a new connection is accepted, the RPCAP protocol starts as usual; the only difference is that the connection is initiated by the server.</p>
<p>This function accepts only ONE connection, then it closes the waiting socket. This means that if some error occurs, the application has to call it again in order to accept another connection.</p>
<p>This function returns when a new connection (coming from a valid host 'connectinghost') is accepted; it returns error otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>a string that keeps the network address we have to bind to; usually it is NULL (it means 'bind on all local addresses').</td></tr>
    <tr><td class="paramname">port</td><td>a string that keeps the network port on which we have to bind to; usually it is NULL (it means 'bind on the predefined port', i.e. RPCAP_DEFAULT_NETPORT_ACTIVE).</td></tr>
    <tr><td class="paramname">hostlist</td><td>a string that keeps the host name of the host from whom we are expecting a connection; it can be NULL (it means 'accept connection from everyone'). Host names are separated by a whatever character in the RPCAP_HOSTLIST_SEP list.</td></tr>
    <tr><td class="paramname">connectinghost</td><td>a user-allocated buffer that will contain the name of the host is trying to connect to us. This variable must be at least RPCAP_HOSTLIST_SIZE bytes..</td></tr>
    <tr><td class="paramname">auth</td><td>a pointer to a pcap_rmtauth structure. This pointer keeps the information required to authenticate the RPCAP connection to the remote host.</td></tr>
    <tr><td class="paramname">errbuf</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The SOCKET identifier of the new control connection if everything is fine, a negative number if some errors occurred. The error message is returned into the errbuf variable. In case it returns '-1', this means 'everything is fine', but the host cannot be admitted. In case it returns '-2', in means 'unrecoverable error' (for example it is not able to bind the socket, or something like that). In case it returns '-3', it means 'authentication failed'. The authentication check is performed only if the connecting host is among the ones that are allowed to connect to this host.</dd></dl>
<p>The host that is connecting to us is returned into the hostlist variable, which ust be allocated by the user. This variable contains the host name both in case the host is allowed, and in case the connection is refused.</p>
<dl class="section warning"><dt>Warning</dt><dd>Although this function returns the socket established by the new control connection, this value should not be used. This value will be stored into some libpcap internal variables and it will be managed automatically by the library. In other words, all the following calls to findalldevs() and <a class="el" href="group__wpcapfunc.html#ga2b64c7b6490090d1d37088794f1f1791" title="Open a generic source in order to capture / send (WinPcap only) traffic. ">pcap_open()</a> will check if the host is among one that already has a control connection in place; if so, that one will be used.</dd>
<dd>
This function has several problems if used inside a thread, which is stopped when this call is blocked into the accept(). In this case, the socket on which we accept connections is not freed (thread termination is a very dirty job), so that we are no longer able to accept other connections until the program (i.e. the process) stops. In order to solve the problem, call the <a class="el" href="group__wpcapfunc.html#ga7b022e0a67f5ff62fd13df5c688d6d82" title="Clean the socket that is currently used in waiting active connections. ">pcap_remoteact_cleanup()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b022e0a67f5ff62fd13df5c688d6d82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcap_remoteact_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean the socket that is currently used in waiting active connections. </p>
<p>This function does a very dirty job. The fact is that is the waiting socket is not freed if the pcap_remoteaccept() is killed inside a new thread. This function is able to clean the socket in order to allow the next calls to <a class="el" href="group__wpcapfunc.html#ga5495943cc8262db57f726e2a23f837dd" title="Block until a network connection is accepted (active mode only). ">pcap_remoteact_accept()</a> to work.</p>
<p>This function is useful <em>only</em> if you launch <a class="el" href="group__wpcapfunc.html#ga5495943cc8262db57f726e2a23f837dd" title="Block until a network connection is accepted (active mode only). ">pcap_remoteact_accept()</a> inside a new thread, and you stops (not very gracefully) the thread (for example because the user changed idea, and it does no longer want to wait for an active connection). So, basically, the flow should be the following:</p><ul>
<li>launch a new thread</li>
<li>call the pcap_remoteact_accept</li>
<li>if this new thread is killed, call <a class="el" href="group__wpcapfunc.html#ga7b022e0a67f5ff62fd13df5c688d6d82" title="Clean the socket that is currently used in waiting active connections. ">pcap_remoteact_cleanup()</a>.</li>
</ul>
<p>This function has no effects in other cases.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a84e03497f946d61c440696e57e2c95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_remoteact_close </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop an active connection (active mode only). </p>
<p>This function has been defined to allow the client dealing with the 'active mode'. This function closes an active connection that is still in place and it purges the host name from the 'activeHost' list. From this point on, the client will not have any connection with that host in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>a string that keeps the host name of the host for which we want to close the active connection.</td></tr>
    <tr><td class="paramname">errbuf</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned into the errbuf variable. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ee8f666bff537aa457b7c05651cf815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_remoteact_list </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>hostlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the hostname of the host that have an active connection with us (active mode only). </p>
<p>This function has been defined to allow the client dealing with the 'active mode'. This function returns the list of hosts that are currently having an active connection with us. This function is useful in order to delete an active connection that is still in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostlist</td><td>a user-allocated string that will keep the list of host that are currently connected with us.</td></tr>
    <tr><td class="paramname">sep</td><td>the character that has to be sued as a separator between the hosts (',' for example).</td></tr>
    <tr><td class="paramname">size</td><td>size of the hostlist buffer.</td></tr>
    <tr><td class="paramname">errbuf</td><td>a pointer to a user-allocated buffer (of size PCAP_ERRBUF_SIZE) that will contain the error message (in case there is one).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'0' if everything is fine, '-1' if some errors occurred. The error message is returned into the errbuf variable. </dd></dl>

</div>
</div>
<a class="anchor" id="ga51dbda0f1ab9da2cfe49d657486d50b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_sendpacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a raw packet. </p>
<p>This function allows to send a raw packet to the network. p is the interface that will be used to send the packet, buf contains the data of the packet to send (including the various protocol headers), size is the dimension of the buffer pointed by buf, i.e. the size of the packet to send. The MAC CRC doesn't need to be included, because it is transparently calculated and added by the network interface driver. The return value is 0 if the packet is succesfully sent, -1 otherwise.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab940e69631b7cc7f2232a69ea02b86d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcap__send__queue.html">pcap_send_queue</a>* pcap_sendqueue_alloc </td>
          <td>(</td>
          <td class="paramtype">u_int&#160;</td>
          <td class="paramname"><em>memsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a send queue. </p>
<p>This function allocates a send queue, i.e. a buffer containing a set of raw packets that will be transimtted on the network with <a class="el" href="group__wpcapfunc.html#gaa4d55eb047a1cccc0e28397ce04ee097" title="Send a queue of raw packets to the network. ">pcap_sendqueue_transmit()</a>.</p>
<p>memsize is the size, in bytes, of the queue, therefore it determines the maximum amount of data that the queue will contain.</p>
<p>Use <a class="el" href="group__wpcapfunc.html#ga4c57ea320d71dbfe55c5665af9db1297" title="Add a packet to a send queue. ">pcap_sendqueue_queue()</a> to insert packets in the queue.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga4c57ea320d71dbfe55c5665af9db1297" title="Add a packet to a send queue. ">pcap_sendqueue_queue()</a>, <a class="el" href="group__wpcapfunc.html#gaa4d55eb047a1cccc0e28397ce04ee097" title="Send a queue of raw packets to the network. ">pcap_sendqueue_transmit()</a>, <a class="el" href="group__wpcapfunc.html#ga72624f7a9932cc2124abf661001e0aa4" title="Destroy a send queue. ">pcap_sendqueue_destroy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga72624f7a9932cc2124abf661001e0aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcap_sendqueue_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a send queue. </p>
<p>Deletes a send queue and frees all the memory associated with it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gab940e69631b7cc7f2232a69ea02b86d9" title="Allocate a send queue. ">pcap_sendqueue_alloc()</a>, <a class="el" href="group__wpcapfunc.html#ga4c57ea320d71dbfe55c5665af9db1297" title="Add a packet to a send queue. ">pcap_sendqueue_queue()</a>, <a class="el" href="group__wpcapfunc.html#gaa4d55eb047a1cccc0e28397ce04ee097" title="Send a queue of raw packets to the network. ">pcap_sendqueue_transmit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c57ea320d71dbfe55c5665af9db1297"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_sendqueue_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> *&#160;</td>
          <td class="paramname"><em>pkt_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u_char *&#160;</td>
          <td class="paramname"><em>pkt_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a packet to a send queue. </p>
<p><a class="el" href="group__wpcapfunc.html#ga4c57ea320d71dbfe55c5665af9db1297" title="Add a packet to a send queue. ">pcap_sendqueue_queue()</a> adds a packet at the end of the send queue pointed by the queue parameter. pkt_header points to a <a class="el" href="structpcap__pkthdr.html" title="Header of a packet in the dump file. ">pcap_pkthdr</a> structure with the timestamp and the length of the packet, pkt_data points to a buffer with the data of the packet.</p>
<p>The <a class="el" href="structpcap__pkthdr.html" title="Header of a packet in the dump file. ">pcap_pkthdr</a> structure is the same used by WinPcap and libpcap to store the packets in a file, therefore sending a capture file is straightforward. 'Raw packet' means that the sending application will have to include the protocol headers, since every packet is sent to the network 'as is'. The CRC of the packets needs not to be calculated, because it will be transparently added by the network interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gab940e69631b7cc7f2232a69ea02b86d9" title="Allocate a send queue. ">pcap_sendqueue_alloc()</a>, <a class="el" href="group__wpcapfunc.html#gaa4d55eb047a1cccc0e28397ce04ee097" title="Send a queue of raw packets to the network. ">pcap_sendqueue_transmit()</a>, <a class="el" href="group__wpcapfunc.html#ga72624f7a9932cc2124abf661001e0aa4" title="Destroy a send queue. ">pcap_sendqueue_destroy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4d55eb047a1cccc0e28397ce04ee097"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int pcap_sendqueue_transmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcap__send__queue.html">pcap_send_queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a queue of raw packets to the network. </p>
<p>This function transmits the content of a queue to the wire. p is a pointer to the adapter on which the packets will be sent, queue points to a <a class="el" href="structpcap__send__queue.html" title="A queue of raw packets that will be sent to the network with pcap_sendqueue_transmit(). ">pcap_send_queue</a> structure containing the packets to send (see <a class="el" href="group__wpcapfunc.html#gab940e69631b7cc7f2232a69ea02b86d9" title="Allocate a send queue. ">pcap_sendqueue_alloc()</a> and <a class="el" href="group__wpcapfunc.html#ga4c57ea320d71dbfe55c5665af9db1297" title="Add a packet to a send queue. ">pcap_sendqueue_queue()</a>), sync determines if the send operation must be synchronized: if it is non-zero, the packets are sent respecting the timestamps, otherwise they are sent as fast as possible.</p>
<p>The return value is the amount of bytes actually sent. If it is smaller than the size parameter, an error occurred during the send. The error can be caused by a driver/adapter problem or by an inconsistent/bogus send queue.</p>
<dl class="section note"><dt>Note</dt><dd>Using this function is more efficient than issuing a series of <a class="el" href="group__wpcapfunc.html#ga51dbda0f1ab9da2cfe49d657486d50b2" title="Send a raw packet. ">pcap_sendpacket()</a>, because the packets are buffered in the kernel driver, so the number of context switches is reduced. Therefore, expect a better throughput when using pcap_sendqueue_transmit.</dd>
<dd>
When Sync is set to TRUE, the packets are synchronized in the kernel with a high precision timestamp. This requires a non-negligible amount of CPU, but allows normally to send the packets with a precision of some microseconds (depending on the accuracy of the performance counter of the machine). Such a precision cannot be reached sending the packets with <a class="el" href="group__wpcapfunc.html#ga51dbda0f1ab9da2cfe49d657486d50b2" title="Send a raw packet. ">pcap_sendpacket()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gab940e69631b7cc7f2232a69ea02b86d9" title="Allocate a send queue. ">pcap_sendqueue_alloc()</a>, <a class="el" href="group__wpcapfunc.html#ga4c57ea320d71dbfe55c5665af9db1297" title="Add a packet to a send queue. ">pcap_sendqueue_queue()</a>, <a class="el" href="group__wpcapfunc.html#ga72624f7a9932cc2124abf661001e0aa4" title="Destroy a send queue. ">pcap_sendqueue_destroy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9588b99ac118cf827873d9e941eb6c77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_set_datalink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dlt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current data link type of the pcap descriptor to the type specified by dlt. -1 is returned on failure. </p>

</div>
</div>
<a class="anchor" id="ga124bde25ccd9e39017ff2abec2dda623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_setbuff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the size of the kernel buffer associated with an adapter. </p>
<p><em>dim</em> specifies the size of the buffer in bytes. The return value is 0 when the call succeeds, -1 otherwise. If an old buffer was already created with a previous call to <a class="el" href="group__wpcapfunc.html#ga124bde25ccd9e39017ff2abec2dda623" title="Set the size of the kernel buffer associated with an adapter. ">pcap_setbuff()</a>, it is deleted and its content is discarded. <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> creates a 1 MByte buffer by default.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a>, <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5f9cfe85dad0967ff607e5159b1ba61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_setfilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bpf_program *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate a filter to a capture. </p>
<p><a class="el" href="group__wpcapfunc.html#gaf5f9cfe85dad0967ff607e5159b1ba61" title="Associate a filter to a capture. ">pcap_setfilter()</a> is used to specify a filter program. fp is a pointer to a bpf_program struct, usually the result of a call to <a class="el" href="group__wpcapfunc.html#ga363bdc6f6b39b4979ddcf15ecb830c5c" title="Compile a packet filter, converting an high level filtering expression (see Filtering expression synt...">pcap_compile()</a>. -1 is returned on failure, in which case <a class="el" href="group__wpcapfunc.html#ga81305cb154e4497e95bbb9b708631a3a" title="return the error text pertaining to the last pcap library error. ">pcap_geterr()</a> may be used to display the error text; 0 is returned on success.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga363bdc6f6b39b4979ddcf15ecb830c5c" title="Compile a packet filter, converting an high level filtering expression (see Filtering expression synt...">pcap_compile()</a>, <a class="el" href="group__wpcapfunc.html#ga8325b202dad14a00609db8372722ae4e" title="Compile a packet filter without the need of opening an adapter. This function converts an high level ...">pcap_compile_nopcap()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab14ceacbf1c2f63026416dd73f80dc0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_setmintocopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minumum amount of data received by the kernel in a single call. </p>
<p><a class="el" href="group__wpcapfunc.html#gab14ceacbf1c2f63026416dd73f80dc0d" title="Set the minumum amount of data received by the kernel in a single call. ">pcap_setmintocopy()</a> changes the minimum amount of data in the kernel buffer that causes a read from the application to return (unless the timeout expires). If the value of <em>size</em> is large, the kernel is forced to wait the arrival of several packets before copying the data to the user. This guarantees a low number of system calls, i.e. low processor usage, and is a good setting for applications like packet-sniffers and protocol analyzers. Vice versa, in presence of a small value for this variable, the kernel will copy the packets as soon as the application is ready to receive them. This is useful for real time applications that need the best responsiveness from the kernel. <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> sets a default mintocopy value of 16000 bytes.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a>, <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaef07ef49d3c75644f3fd34518e2fe720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_setmode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the working mode of the interface p to mode. </p>
<p>Valid values for mode are MODE_CAPT (default capture mode) and MODE_STAT (statistical mode). See the tutorial "\ref wpcap_tut9" for details about statistical mode. </p>

</div>
</div>
<a class="anchor" id="ga3f212141c80b59aad8ac535bb0178275"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_setnonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nonblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch between blocking and nonblocking mode. </p>
<p><a class="el" href="group__wpcapfunc.html#ga3f212141c80b59aad8ac535bb0178275" title="Switch between blocking and nonblocking mode. ">pcap_setnonblock()</a> puts a capture descriptor, opened with <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, into "non-blocking" mode, or takes it out of "non-blocking" mode, depending on whether the nonblock argument is non-zero or zero. It has no effect on "savefiles". If there is an error, -1 is returned and errbuf is filled in with an appropriate error message; otherwise, 0 is returned. In "non-blocking" mode, an attempt to read from the capture descriptor with <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> will, if no packets are currently available to be read, return 0 immediately rather than blocking waiting for packets to arrive. <a class="el" href="group__wpcapfunc.html#ga6bcb7c5c59d76ec16b8a699da136b5de" title="Collect a group of packets. ">pcap_loop()</a> and <a class="el" href="group__wpcapfunc.html#gadf60257f650aaf869671e0a163611fc3" title="Return the next available packet. ">pcap_next()</a> will not work in "non-blocking" mode.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gab25dc0bfe06545b86be4103bf010708e" title="Get the &quot;non-blocking&quot; state of an interface. ">pcap_getnonblock()</a>, <a class="el" href="group__wpcapfunc.html#ga60ce104cdf28420d3361cd36d15be44c" title="Collect a group of packets. ">pcap_dispatch()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga84c7d55f5b0e7d545b38d6b8e7bde005"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct pcap_samp* pcap_setsampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a sampling method for packet capture. </p>
<p>This function allows applying a sampling method to the packet capture process. The currently sampling methods (and the way to set them) are described into the struct pcap_samp. In other words, the user must set the appropriate parameters into it; these will be applied as soon as the capture starts.</p>
<dl class="section warning"><dt>Warning</dt><dd>Sampling parameters <b>cannot</b> be changed when a capture is active. These parameters must be applied <b>before</b> starting the capture. If they are applied when the capture is in progress, the new settings are ignored.</dd>
<dd>
Sampling works only when capturing data on Win32 or reading from a file. It has not been implemented on other platforms. Sampling works on remote machines provided that the probe (i.e. the capturing device) is a Win32 workstation. </dd></dl>

</div>
</div>
<a class="anchor" id="gae5c6e9768e89a6b82f9d720f37e6ab97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_snapshot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimension of the packet portion (in bytes) that is delivered to the application. </p>
<p><a class="el" href="group__wpcapfunc.html#gae5c6e9768e89a6b82f9d720f37e6ab97" title="Return the dimension of the packet portion (in bytes) that is delivered to the application. ">pcap_snapshot()</a> returns the snapshot length specified when pcap_open_live was called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a>, <a class="el" href="group__wpcapfunc.html#ga363bdc6f6b39b4979ddcf15ecb830c5c" title="Compile a packet filter, converting an high level filtering expression (see Filtering expression synt...">pcap_compile()</a>, <a class="el" href="group__wpcapfunc.html#ga8325b202dad14a00609db8372722ae4e" title="Compile a packet filter without the need of opening an adapter. This function converts an high level ...">pcap_compile_nopcap()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabbd74d8c3ce1bcbccc76129ac38f4549"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcap_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpcap__stat.html">pcap_stat</a> *&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return statistics on current capture. </p>
<p><a class="el" href="group__wpcapfunc.html#gabbd74d8c3ce1bcbccc76129ac38f4549" title="Return statistics on current capture. ">pcap_stats()</a> returns 0 and fills in a <a class="el" href="structpcap__stat.html" title="Structure that keeps statistical values on an interface. ">pcap_stat</a> struct. The values represent packet statistics from the start of the run to the time of the call. If there is an error or the underlying packet capture doesn't support packet statistics, -1 is returned and the error text can be obtained with <a class="el" href="group__wpcapfunc.html#gac3b6784c6c2623b93b22f6f219bd470e" title="print the text of the last pcap library error on stderr, prefixed by prefix. ">pcap_perror()</a> or <a class="el" href="group__wpcapfunc.html#ga81305cb154e4497e95bbb9b708631a3a" title="return the error text pertaining to the last pcap library error. ">pcap_geterr()</a>. <a class="el" href="group__wpcapfunc.html#gabbd74d8c3ce1bcbccc76129ac38f4549" title="Return statistics on current capture. ">pcap_stats()</a> is supported only on live captures, not on "savefiles"; no statistics are stored in "savefiles", so no statistics are available when reading from a "savefile".</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#ga8050f7829956aabd243cc32b3cfabbd6" title="Return statistics on current capture. ">pcap_stats_ex()</a>, <a class="el" href="group__wpcapfunc.html#gaae6abe06e15c87b803f69773822beca8" title="Open a live capture from the network. ">pcap_open_live()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8050f7829956aabd243cc32b3cfabbd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpcap__stat.html">pcap_stat</a>* pcap_stats_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__wpcap__def.html#ga4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pcap_stat_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return statistics on current capture. </p>
<p><a class="el" href="group__wpcapfunc.html#ga8050f7829956aabd243cc32b3cfabbd6" title="Return statistics on current capture. ">pcap_stats_ex()</a> extends the <a class="el" href="group__wpcapfunc.html#gabbd74d8c3ce1bcbccc76129ac38f4549" title="Return statistics on current capture. ">pcap_stats()</a> allowing to return more statistical parameters than the old call. One of the advantages of this new call is that the <a class="el" href="structpcap__stat.html" title="Structure that keeps statistical values on an interface. ">pcap_stat</a> structure is not allocated by the user; instead, it is returned back by the system. This allow to extend the <a class="el" href="structpcap__stat.html" title="Structure that keeps statistical values on an interface. ">pcap_stat</a> structure without affecting backward compatibility on older applications. These will simply check at the values of the members at the beginning of the structure, while only newest applications are able to read new statistical values, which are appended in tail.</p>
<p>To be sure not to read a piece of mamory which has not been allocated by the system, the variable pcap_stat_size will return back the size of the structure <a class="el" href="structpcap__stat.html" title="Structure that keeps statistical values on an interface. ">pcap_stat</a> allocated by the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer to the pcap_t currently in use. </td></tr>
    <tr><td class="paramname">pcap_stat_size</td><td>pointer to an integer that will contain (when the function returns back) the size of the structure <a class="el" href="structpcap__stat.html" title="Structure that keeps statistical values on an interface. ">pcap_stat</a> as it has been allocated by the system.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: a pointer to a <a class="el" href="structpcap__stat.html" title="Structure that keeps statistical values on an interface. ">pcap_stat</a> structure, that will contain the statistics related to the current device. The return value is NULL in case of errors, and the error text can be obtained with <a class="el" href="group__wpcapfunc.html#gac3b6784c6c2623b93b22f6f219bd470e" title="print the text of the last pcap library error on stderr, prefixed by prefix. ">pcap_perror()</a> or <a class="el" href="group__wpcapfunc.html#ga81305cb154e4497e95bbb9b708631a3a" title="return the error text pertaining to the last pcap library error. ">pcap_geterr()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="group__wpcapfunc.html#ga8050f7829956aabd243cc32b3cfabbd6" title="Return statistics on current capture. ">pcap_stats_ex()</a> is supported only on live captures, not on "savefiles"; no statistics are stored in "savefiles", so no statistics are available when reading from a "savefile".</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gabbd74d8c3ce1bcbccc76129ac38f4549" title="Return statistics on current capture. ">pcap_stats()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafac2067e8f66f5a5a87f19f5e2b5ad4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pcap_strerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provided in case strerror() isn't available. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wpcapfunc.html#gac3b6784c6c2623b93b22f6f219bd470e" title="print the text of the last pcap library error on stderr, prefixed by prefix. ">pcap_perror()</a>, <a class="el" href="group__wpcapfunc.html#ga81305cb154e4497e95bbb9b708631a3a" title="return the error text pertaining to the last pcap library error. ">pcap_geterr()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->

<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005-2010
CACE Technologies. Copyright (c) 2010-2013
Riverbed Technology. All rights reserved.</p>
